#include <fcntl.h>

#include "Benchmarker.h"
#include "Utils.h"

#include <libethereum/Executive.h>

namespace
{

const uint64_t warmupCount = 3;

void dropCache()
{
    sync();

    std::ofstream ofs("/proc/sys/vm/drop_caches");
    ofs << "3" << std::endl;
    ofs.close();
    if(!ofs)
    {
        throw std::runtime_error("failed to drop cache");
    }
}

}

namespace dev
{
namespace eth
{
Json::Value BenchmarkStats::toJson(bool verbose) const
{
    Json::Value root;
    root["blockExecutionTimeMean"] = blockExecutionTimeMean;
    root["blockExecutionTimeMedian"] = blockExecutionTimeMedian;
    root["blockExecutionTimeStdev"] = blockExecutionTimeStdev;
    root["blockGas"] = blockGas;
    root["blockThroughputMean"] = blockThroughputMean;
    root["blockThroughputMedian"] = blockThroughputMedian;
    root["blockExecutionTimes"] = Json::Value(Json::arrayValue);
    for (auto executionTime : blockExecutionTimes)
    {
        root["blockExecutionTimes"].append(executionTime);
    }

    if (verbose)
    {
        root["programStats"] = Json::Value(Json::arrayValue);
        for (auto& programStat : programStats)
        {
            root["programStats"].append(programStat.toJson());
        }
    }

    return root;
}


ExecutionStats executeCode(const Address& contractDestination, const ExecutionEnv& execEnv,
    State& state, BlockHeader& blockHeader, bool debug)
{
    bytes data;
    Transaction t;

    auto nonce = state.getNonce(execEnv.sender);
    t = Transaction(execEnv.value, execEnv.gasPrice, execEnv.gas, contractDestination, data, nonce);

    state.addBalance(execEnv.sender, execEnv.value);

    auto se = execEnv.chain->sealEngine();
    EnvInfo const envInfo(blockHeader, execEnv.chain->lastBlockHashes(), 0);
    Executive executive(state, envInfo, *se);
    ExecutionResult res;
    executive.setResultRecipient(res);
    t.forceSender(execEnv.sender);

    executive.initialize(t);
    executive.call(contractDestination, execEnv.sender, execEnv.value, execEnv.gasPrice, &data, execEnv.gas);

    if (debug)
    {
        auto onOp = executive.traceInstructions(debug);
        executive.go(onOp);
    }
    else
    {
        executive.go();
    }

    executive.finalize();

    return ExecutionStats {
        .gasUsed = executive.gasUsed(),
        .executionTime = executive.executionTime(),
        .output = res.output,
        .excepted = res.excepted
    };
}


ExecutionStats executeCode(bytes code, ExecutionEnv execEnv, bool debug)
{
    auto block = execEnv.block;
    auto state = block.mutableState();

    Address contractDestination("1122334455667788991011121314151617181920");
    Account account(0, 0);
    account.setCode(bytes{code});
    std::unordered_map<Address, Account> map;
    map[contractDestination] = account;
    state.populateFrom(map);

    return executeCode(contractDestination, execEnv, state, execEnv.blockHeader, debug);
}


ExecutionAggregatedStats benchmarkCode(ExecutionEnv execEnv, bytes code, BenchmarkConfig config)
{
    std::vector<double> measurements;
    u256 gasUsed = 0;
    bytes output;

    if (config.dropCaches)
    {
        dropCache();
    }

    if (config.warmup)
    {
        for (uint64_t i = 0; i < warmupCount; i++)
        {
            executeCode(code, execEnv, config.debug);
        }
    }

    for (uint64_t i = 0; i < config.execCount; i++)
    {
        if (config.alwaysDropCache)
        {
            dropCache();
        }
        auto stats = executeCode(code, execEnv, config.debug);
        if (stats.excepted != TransactionException::None)
        {
            std::stringstream ss;
            ss << "exception: " << stats.excepted;
            throw std::runtime_error(ss.str().c_str());
        }

        if (output.empty())
        {
            output = stats.output;
        }
        else if (output != stats.output)
        {
            throw std::runtime_error("obtained different output");
        }

        if (gasUsed == 0)
        {
            gasUsed = stats.gasUsed;
        }
        else if (gasUsed != stats.gasUsed)
        {
            std::stringstream ss;
            ss << "obtained different gas used: '" << gasUsed
               << "' != '" << stats.gasUsed << "'";
            throw std::runtime_error(ss.str().c_str());
        }

        measurements.push_back(stats.executionTime);
    }

    double totalTime = math::sum(measurements.begin(), measurements.end());
    double medianTime = math::constMedian(measurements.begin(), measurements.end());
    return ExecutionAggregatedStats{
        .gas = gasUsed.convert_to<uint64_t>(),
        .execCount = config.execCount,
        .totalTime = totalTime,
        .gasPerSecond = gasUsed.convert_to<double>() / totalTime * config.execCount,
        .timeMean = math::mean(measurements.begin(), measurements.end()),
        .timeStdev = math::stdev(measurements.begin(), measurements.end()),
        .timeMedian = medianTime,
        .medianGasPerSecond = gasUsed.convert_to<double>() / medianTime,
        .measurements = measurements,
    };
}


BenchmarkStats benchmarkCodes(
    ExecutionEnv execEnv, const std::vector<bytes>& codes, BenchmarkConfig config)
{
    std::vector<std::vector<double>> measurements(codes.size());
    std::vector<u256> gasUsed(codes.size(), 0);
    std::vector<bytes> outputs(codes.size());

    std::unordered_map<Address, Account> map;
    std::vector<Address> addresses;
    std::string baseAddress = "1122334455667788991011121314151617181920";
    size_t codeIndexLength = static_cast<size_t>(ceil(log10(codes.size())));
    baseAddress = baseAddress.substr(0, baseAddress.size() - codeIndexLength);
    for (size_t i = 0; i < codes.size(); i++)
    {
        std::ostringstream oss;
        oss << baseAddress << std::setw(codeIndexLength) << std::setfill('0') << i;
        Address contractDestination(oss.str());
        Account account(0, 0);
        addresses.push_back(contractDestination);
        account.setCode(bytes{codes[i]});
        map[contractDestination] = account;
    }

    std::vector<double> blockExecutionTimes;

    for (uint64_t i = 0; i < config.execCount; i++)
    {
        if (config.dropCaches)
        {
            dropCache();
        }

        // Execute all the contracts as if they were part of the same block
        auto block = execEnv.block;
        auto& state = block.mutableState();
        auto blockHeader = execEnv.blockHeader;
        state.populateFrom(map);

        double totalExecutionTime = 0.0;

        for (size_t j = 0; j < codes.size(); j++)
        {
            if (config.alwaysDropCache)
            {
                dropCache();
            }

            auto stats = executeCode(addresses[j], execEnv, state, blockHeader, config.debug);

            if (stats.excepted != TransactionException::None)
            {
                std::stringstream ss;
                ss << "exception: " << stats.excepted;
                throw std::runtime_error(ss.str().c_str());
            }
            totalExecutionTime += stats.executionTime;

            if (outputs[j].empty())
            {
                outputs[j] = stats.output;
            }
            else if (outputs[j] != stats.output)
            {
                throw std::runtime_error("obtained different output");
            }

            if (gasUsed[j] == 0)
            {
                gasUsed[j] = stats.gasUsed;
            }
            else if (gasUsed[j] != stats.gasUsed)
            {
                std::stringstream ss;
                ss << "obtained different gas used: '" << gasUsed[j]
                   << "' != '" << stats.gasUsed << "'";
                throw std::runtime_error(ss.str().c_str());
            }

            measurements[j].push_back(stats.executionTime);
        }

        blockExecutionTimes.push_back(totalExecutionTime);
    }

    std::vector<ExecutionAggregatedStats> results(codes.size());

    u256 blockGas = 0;
    for (size_t i = 0; i < codes.size(); i++)
    {
        auto& codeMeasurements = measurements[i];
        double totalTime = math::sum(codeMeasurements.begin(), codeMeasurements.end());
        double medianTime = math::constMedian(codeMeasurements.begin(), codeMeasurements.end());
        auto gas = gasUsed[i];
        blockGas += gas;
        results[i] = ExecutionAggregatedStats{
            .gas = gas.convert_to<uint64_t>(),
            .execCount = config.execCount,
            .totalTime = totalTime,
            .gasPerSecond = gas.convert_to<double>() / totalTime * config.execCount,
            .timeMean = math::mean(codeMeasurements.begin(), codeMeasurements.end()),
            .timeStdev = math::stdev(codeMeasurements.begin(), codeMeasurements.end()),
            .timeMedian = medianTime,
            .medianGasPerSecond = gas.convert_to<double>() / medianTime,
            .measurements = measurements[i],
        };
    }

    auto blockExecTimeMean = math::mean(blockExecutionTimes.begin(), blockExecutionTimes.end());
    auto blockExecTimeMedian = math::constMedian(blockExecutionTimes.begin(), blockExecutionTimes.end());
    auto blockGasD = blockGas.convert_to<double>();

    return BenchmarkStats{
        .blockExecutionTimeMean = blockExecTimeMean,
        .blockExecutionTimeMedian = blockExecTimeMedian,
        .blockExecutionTimeStdev =
            math::stdev(blockExecutionTimes.begin(), blockExecutionTimes.end()),
        .blockGas = blockGasD,
        .blockThroughputMean = blockGasD / blockExecTimeMean,
        .blockThroughputMedian = blockGasD / blockExecTimeMedian,
        .blockExecutionTimes = blockExecutionTimes,
        .programStats = results,
    };
}


}
}
