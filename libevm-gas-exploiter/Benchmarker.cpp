#include "Benchmarker.h"

#include <libethereum/Executive.h>

namespace dev
{
namespace eth
{

using namespace boost::accumulators;


ExecutionStats executeCode(bytes code, ExecutionEnv execEnv, bool debug)
{
    auto block = execEnv.block;
    auto state = block.mutableState();
    auto blockHeader = execEnv.blockHeader;
    bytes data;

    Transaction t;
    Address contractDestination("1122334455667788991011121314151617181920");
    Account account(0, 0);
    account.setCode(bytes{code});
    std::unordered_map<Address, Account> map;
    map[contractDestination] = account;
    state.populateFrom(map);
    t = Transaction(execEnv.value, execEnv.gasPrice, execEnv.gas, contractDestination, data, 0);

    state.addBalance(execEnv.sender, execEnv.value);

    auto se = execEnv.chain->sealEngine();
    EnvInfo const envInfo(blockHeader, execEnv.chain->lastBlockHashes(), 0);
    Executive executive(state, envInfo, *se);
    ExecutionResult res;
    executive.setResultRecipient(res);
    t.forceSender(execEnv.sender);

    std::unordered_map<byte, std::pair<unsigned, bigint>> counts;

    executive.initialize(t);
    executive.call(contractDestination, execEnv.sender, execEnv.value, execEnv.gasPrice, &data, execEnv.gas);

    if (debug)
    {
        auto onOp = executive.traceInstructions(debug);
        executive.go(onOp);
    }
    else
    {
        executive.go();
    }

    executive.finalize();

    return ExecutionStats {
        .gasUsed = executive.gasUsed(),
        .executionTime = executive.executionTime(),
        .output = res.output,
        .excepted = res.excepted
    };
}

ExecutionAggregatedStats benchmarkCode(ExecutionEnv execEnv, bytes code, uint64_t execCount, bool debug)
{
    accumulator_set<double, features<tag::sum, tag::mean, tag::variance>> timeMeasurements;
    u256 gasUsed = 0;
    bytes output;

    for (uint64_t i = 0; i < execCount; i++)
    {
        auto stats = executeCode(code, execEnv, debug);
        auto exception = stats.excepted != TransactionException::None;
        if (exception)
        {
            std::stringstream ss;
            ss << "exception: " << stats.excepted;
            throw std::runtime_error(ss.str().c_str());
        }

        if (output.empty())
        {
            output = stats.output;
        }
        else if (output != stats.output)
        {
            throw std::runtime_error("obtained different output");
        }

        if (gasUsed == 0)
        {
            gasUsed = stats.gasUsed;
        }
        else if (gasUsed != stats.gasUsed)
        {
            std::stringstream ss;
            ss << "obtained different gas used: '" << gasUsed
               << "' != '" << stats.gasUsed << "'";
            throw std::runtime_error(ss.str().c_str());
        }

        timeMeasurements(stats.executionTime);
    }

    double totalTime = sum(timeMeasurements);
    return ExecutionAggregatedStats {
        .gas = gasUsed.convert_to<uint64_t>(),
        .totalTime = totalTime,
        .gasPerSecond = gasUsed.convert_to<double>() / totalTime * execCount,
        .timeMean = mean(timeMeasurements),
        .timeStdev = sqrt(variance(timeMeasurements))
    };
}

}
}