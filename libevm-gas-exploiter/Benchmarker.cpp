#include <fcntl.h>

#include "Benchmarker.h"

#include <libethereum/Executive.h>

namespace
{

const uint64_t warmupCount = 3;

void dropCache()
{
    sync();

    std::ofstream ofs("/proc/sys/vm/drop_caches");
    ofs << "3" << std::endl;
    ofs.close();
    if(!ofs)
    {
        throw std::runtime_error("failed to drop cache");
    }
}

}

namespace dev
{
namespace eth
{

using namespace boost::accumulators;


ExecutionStats executeCode(bytes code, ExecutionEnv execEnv, bool debug)
{
    auto block = execEnv.block;
    auto state = block.mutableState();
    auto blockHeader = execEnv.blockHeader;
    bytes data;

    Transaction t;
    Address contractDestination("1122334455667788991011121314151617181920");
    Account account(0, 0);
    account.setCode(bytes{code});
    std::unordered_map<Address, Account> map;
    map[contractDestination] = account;
    state.populateFrom(map);
    t = Transaction(execEnv.value, execEnv.gasPrice, execEnv.gas, contractDestination, data, 0);

    state.addBalance(execEnv.sender, execEnv.value);

    auto se = execEnv.chain->sealEngine();
    EnvInfo const envInfo(blockHeader, execEnv.chain->lastBlockHashes(), 0);
    Executive executive(state, envInfo, *se);
    ExecutionResult res;
    executive.setResultRecipient(res);
    t.forceSender(execEnv.sender);

    std::unordered_map<byte, std::pair<unsigned, bigint>> counts;

    executive.initialize(t);
    executive.call(contractDestination, execEnv.sender, execEnv.value, execEnv.gasPrice, &data, execEnv.gas);

    if (debug)
    {
        auto onOp = executive.traceInstructions(debug);
        executive.go(onOp);
    }
    else
    {
        executive.go();
    }

    executive.finalize();

    return ExecutionStats {
        .gasUsed = executive.gasUsed(),
        .executionTime = executive.executionTime(),
        .output = res.output,
        .excepted = res.excepted
    };
}

ExecutionAggregatedStats benchmarkCode(ExecutionEnv execEnv, bytes code, BenchmarkConfig config)
{
    accumulator_set<double, features<tag::sum, tag::mean, tag::variance>> aggregatedMeasurements;
    std::vector<double> measurements;
    u256 gasUsed = 0;
    bytes output;

    if (config.dropCaches)
    {
        dropCache();
    }

    if (config.warmup)
    {
        for (uint64_t i = 0; i < warmupCount; i++)
        {
            executeCode(code, execEnv, config.debug);
        }
    }

    for (uint64_t i = 0; i < config.execCount; i++)
    {
        if (config.alwaysDropCache)
        {
            dropCache();
        }
        auto stats = executeCode(code, execEnv, config.debug);
        if (stats.excepted != TransactionException::None)
        {
            std::stringstream ss;
            ss << "exception: " << stats.excepted;
            throw std::runtime_error(ss.str().c_str());
        }

        if (output.empty())
        {
            output = stats.output;
        }
        else if (output != stats.output)
        {
            throw std::runtime_error("obtained different output");
        }

        if (gasUsed == 0)
        {
            gasUsed = stats.gasUsed;
        }
        else if (gasUsed != stats.gasUsed)
        {
            std::stringstream ss;
            ss << "obtained different gas used: '" << gasUsed
               << "' != '" << stats.gasUsed << "'";
            throw std::runtime_error(ss.str().c_str());
        }

        aggregatedMeasurements(stats.executionTime);
        measurements.push_back(stats.executionTime);
    }

    double totalTime = sum(aggregatedMeasurements);
    double medianTime = constMedian(measurements.begin(), measurements.end());
    return ExecutionAggregatedStats {
        .gas = gasUsed.convert_to<uint64_t>(),
        .execCount = config.execCount,
        .totalTime = totalTime,
        .gasPerSecond = gasUsed.convert_to<double>() / totalTime * config.execCount,
        .timeMean = mean(aggregatedMeasurements),
        .timeStdev = sqrt(variance(aggregatedMeasurements)),
        .timeMedian = medianTime,
        .medianGasPerSecond = gasUsed.convert_to<double>() / medianTime,
        .measurements = measurements,
    };
}


std::vector<ExecutionAggregatedStats> benchmarkCodes(ExecutionEnv execEnv, const std::vector<bytes>& codes, BenchmarkConfig config)
{
    std::vector<accumulator_set<double, features<tag::sum, tag::mean, tag::variance>>> aggregatedMeasurements(codes.size());
    std::vector<std::vector<double>> measurements(codes.size());
    std::vector<u256> gasUsed(codes.size(), 0);
    std::vector<bytes> outputs(codes.size());

    for (uint64_t i = 0; i < config.execCount; i++)
    {
        if (config.dropCaches)
        {
            dropCache();
        }

        for (size_t j = 0; j < codes.size(); j++)
        {
            const auto& code = codes[j];
            if (config.alwaysDropCache)
            {
                dropCache();
            }

            auto stats = executeCode(code, execEnv, config.debug);
            if (stats.excepted != TransactionException::None)
            {
                std::stringstream ss;
                ss << "exception: " << stats.excepted;
                throw std::runtime_error(ss.str().c_str());
            }

            if (outputs[j].empty())
            {
                outputs[j] = stats.output;
            }
            else if (outputs[j] != stats.output)
            {
                throw std::runtime_error("obtained different output");
            }

            if (gasUsed[j] == 0)
            {
                gasUsed[j] = stats.gasUsed;
            }
            else if (gasUsed[j] != stats.gasUsed)
            {
                std::stringstream ss;
                ss << "obtained different gas used: '" << gasUsed[j]
                   << "' != '" << stats.gasUsed << "'";
                throw std::runtime_error(ss.str().c_str());
            }

            aggregatedMeasurements[j](stats.executionTime);
            measurements[j].push_back(stats.executionTime);
        }
    }

    std::vector<ExecutionAggregatedStats> results(codes.size());

    for (size_t i = 0; i < codes.size(); i++)
    {
        double totalTime = sum(aggregatedMeasurements[i]);
        double medianTime = constMedian(measurements[i].begin(), measurements[i].end());
        auto gas = gasUsed[i];
        results[i] = ExecutionAggregatedStats {
            .gas = gas.convert_to<uint64_t>(),
            .execCount = config.execCount,
            .totalTime = totalTime,
            .gasPerSecond = gas.convert_to<double>() / totalTime * config.execCount,
            .timeMean = mean(aggregatedMeasurements[i]),
            .timeStdev = sqrt(variance(aggregatedMeasurements[i])),
            .timeMedian = medianTime,
            .medianGasPerSecond = gas.convert_to<double>() / medianTime,
            .measurements = measurements[i],
        };
    }

    return results;
}


}
}
