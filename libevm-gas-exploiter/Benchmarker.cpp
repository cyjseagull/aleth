#include <fcntl.h>

#include "Benchmarker.h"

#include <libethereum/Executive.h>

namespace
{

const uint64_t warmupCount = 3;

void flushCache()
{
    sync();

    std::ofstream ofs("/proc/sys/vm/drop_caches");
    ofs << "3" << std::endl;
    ofs.close();
    if(!ofs)
    {
        throw std::runtime_error("failed to flush cache");
    }
}

}

namespace dev
{
namespace eth
{

using namespace boost::accumulators;


ExecutionStats executeCode(bytes code, ExecutionEnv execEnv, bool debug)
{
    auto block = execEnv.block;
    auto state = block.mutableState();
    auto blockHeader = execEnv.blockHeader;
    bytes data;

    Transaction t;
    Address contractDestination("1122334455667788991011121314151617181920");
    Account account(0, 0);
    account.setCode(bytes{code});
    std::unordered_map<Address, Account> map;
    map[contractDestination] = account;
    state.populateFrom(map);
    t = Transaction(execEnv.value, execEnv.gasPrice, execEnv.gas, contractDestination, data, 0);

    state.addBalance(execEnv.sender, execEnv.value);

    auto se = execEnv.chain->sealEngine();
    EnvInfo const envInfo(blockHeader, execEnv.chain->lastBlockHashes(), 0);
    Executive executive(state, envInfo, *se);
    ExecutionResult res;
    executive.setResultRecipient(res);
    t.forceSender(execEnv.sender);

    std::unordered_map<byte, std::pair<unsigned, bigint>> counts;

    executive.initialize(t);
    executive.call(contractDestination, execEnv.sender, execEnv.value, execEnv.gasPrice, &data, execEnv.gas);

    if (debug)
    {
        auto onOp = executive.traceInstructions(debug);
        executive.go(onOp);
    }
    else
    {
        executive.go();
    }

    executive.finalize();

    return ExecutionStats {
        .gasUsed = executive.gasUsed(),
        .executionTime = executive.executionTime(),
        .output = res.output,
        .excepted = res.excepted
    };
}

ExecutionAggregatedStats benchmarkCode(ExecutionEnv execEnv, bytes code, BenchmarkConfig config)
{
    accumulator_set<double, features<tag::sum, tag::mean, tag::variance>> aggregatedMeasurements;
    std::vector<double> measurements;
    u256 gasUsed = 0;
    bytes output;

    if (config.dropCaches)
    {
        flushCache();
    }

    if (config.warmup)
    {
        for (uint64_t i = 0; i < warmupCount; i++)
        {
            executeCode(code, execEnv, config.debug);
        }
    }

    for (uint64_t i = 0; i < config.execCount; i++)
    {
        if (config.flush)
        {
            flushCache();
        }
        auto stats = executeCode(code, execEnv, config.debug);
        if (stats.excepted != TransactionException::None)
        {
            std::stringstream ss;
            ss << "exception: " << stats.excepted;
            throw std::runtime_error(ss.str().c_str());
        }

        if (output.empty())
        {
            output = stats.output;
        }
        else if (output != stats.output)
        {
            throw std::runtime_error("obtained different output");
        }

        if (gasUsed == 0)
        {
            gasUsed = stats.gasUsed;
        }
        else if (gasUsed != stats.gasUsed)
        {
            std::stringstream ss;
            ss << "obtained different gas used: '" << gasUsed
               << "' != '" << stats.gasUsed << "'";
            throw std::runtime_error(ss.str().c_str());
        }

        aggregatedMeasurements(stats.executionTime);
        if (config.recordAll)
        {
            measurements.push_back(stats.executionTime);
        }
    }

    double totalTime = sum(aggregatedMeasurements);
    return ExecutionAggregatedStats {
        .gas = gasUsed.convert_to<uint64_t>(),
        .execCount = config.execCount,
        .totalTime = totalTime,
        .gasPerSecond = gasUsed.convert_to<double>() / totalTime * config.execCount,
        .timeMean = mean(aggregatedMeasurements),
        .timeStdev = sqrt(variance(aggregatedMeasurements)),
        .measurements = measurements,
    };
}

}
}