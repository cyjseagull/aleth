#include "ProgramGenerator.h"
#include "GasEstimator.h"

#include <libdevcore/Common.h>


namespace
{
    const uint8_t maxArgsNeeded = 17;
    const double defaultWeight = 0.001;
}

namespace dev
{
namespace eth
{

static const std::vector<Instruction> validInstructions = {
    Instruction::ADD,
    Instruction::MUL,
    Instruction::SUB,
    Instruction::DIV,
    Instruction::SDIV,
    Instruction::MOD,
    Instruction::SMOD,
    Instruction::ADDMOD,
    Instruction::MULMOD,
    Instruction::EXP,
    Instruction::SIGNEXTEND,
    Instruction::LT ,
    Instruction::GT,
    Instruction::SLT,
    Instruction::SGT,
    Instruction::EQ,
    Instruction::ISZERO,
    Instruction::AND,
    Instruction::OR,
    Instruction::XOR,
    Instruction::NOT,
    Instruction::BYTE,
    Instruction::SHL,
    Instruction::SHR,
    Instruction::SAR,
    Instruction::SHA3 ,
    Instruction::ADDRESS ,
    Instruction::BALANCE,
    Instruction::ORIGIN,
    Instruction::CALLER,
    Instruction::CALLVALUE,
    Instruction::CALLDATALOAD,
    Instruction::CALLDATASIZE,
    Instruction::CALLDATACOPY,
    Instruction::CODESIZE,
    Instruction::CODECOPY,
    Instruction::GASPRICE,
    Instruction::EXTCODESIZE,
    Instruction::EXTCODECOPY,
    Instruction::RETURNDATASIZE ,
    Instruction::RETURNDATACOPY ,
    Instruction::EXTCODEHASH ,
    Instruction::BLOCKHASH ,
    Instruction::COINBASE,
    Instruction::TIMESTAMP,
    Instruction::NUMBER,
    Instruction::DIFFICULTY,
    Instruction::GASLIMIT,
    Instruction::POP ,
    Instruction::MLOAD,
    Instruction::MSTORE,
    Instruction::MSTORE8,
    Instruction::SLOAD,
    Instruction::SSTORE,
    // JUMP and JUMPI would most likely result in infinite loops
    // Instruction::JUMP,
    // Instruction::JUMPI,
    Instruction::PC,
    Instruction::MSIZE,
    Instruction::GAS,
    Instruction::JUMPDEST,
    Instruction::PUSH1 ,
    Instruction::PUSH2,
    Instruction::PUSH3,
    Instruction::PUSH4,
    Instruction::PUSH5,
    Instruction::PUSH6,
    Instruction::PUSH7,
    Instruction::PUSH8,
    Instruction::PUSH9,
    Instruction::PUSH10,
    Instruction::PUSH11,
    Instruction::PUSH12,
    Instruction::PUSH13,
    Instruction::PUSH14,
    Instruction::PUSH15,
    Instruction::PUSH16,
    Instruction::PUSH17,
    Instruction::PUSH18,
    Instruction::PUSH19,
    Instruction::PUSH20,
    Instruction::PUSH21,
    Instruction::PUSH22,
    Instruction::PUSH23,
    Instruction::PUSH24,
    Instruction::PUSH25,
    Instruction::PUSH26,
    Instruction::PUSH27,
    Instruction::PUSH28,
    Instruction::PUSH29,
    Instruction::PUSH30,
    Instruction::PUSH31,
    Instruction::PUSH32,
    Instruction::DUP1 ,
    Instruction::DUP2,
    Instruction::DUP3,
    Instruction::DUP4,
    Instruction::DUP5,
    Instruction::DUP6,
    Instruction::DUP7,
    Instruction::DUP8,
    Instruction::DUP9,
    Instruction::DUP10,
    Instruction::DUP11,
    Instruction::DUP12,
    Instruction::DUP13,
    Instruction::DUP14,
    Instruction::DUP15,
    Instruction::DUP16,
    Instruction::SWAP1 ,
    Instruction::SWAP2,
    Instruction::SWAP3,
    Instruction::SWAP4,
    Instruction::SWAP5,
    Instruction::SWAP6,
    Instruction::SWAP7,
    Instruction::SWAP8,
    Instruction::SWAP9,
    Instruction::SWAP10,
    Instruction::SWAP11,
    Instruction::SWAP12,
    Instruction::SWAP13,
    Instruction::SWAP14,
    Instruction::SWAP15,
    Instruction::SWAP16,
    Instruction::LOG0 ,
    Instruction::LOG1,
    Instruction::LOG2,
    Instruction::LOG3,
    Instruction::LOG4,
};


ProgramGenerator::ProgramGenerator(
    std::map<Instruction, InstructionMetadata> metadata,
    unsigned seed
) : m_generator(std::default_random_engine(seed))
{
    m_u256Generator = u256_random_generator(seed);

    auto schedule = ByzantiumSchedule;

    GasEstimator gasEstimator(schedule);

    // initialize instructions

    std::map<int, std::vector<double>> distributionsWeights;

    for (auto instruction: validInstructions)
    {
        auto info = instructionInfo(instruction);
        auto estimatedGas = gasEstimator.estimateGas(instruction);
        if (estimatedGas == 0)
        {
            estimatedGas = 1;
        }
        auto instrMetadata = metadata[instruction];
        double weight = 0.001;
        if (instrMetadata.executedCount > 0)
        {
            weight = std::log(instrMetadata.executionTimeMean / estimatedGas + 1);
        }
        for (uint8_t argsCount = info.args; argsCount < maxArgsNeeded; argsCount++)
        {
            m_instructionsPerArgsCount[argsCount].push_back(instruction);
            distributionsWeights[argsCount].push_back(weight);
        }
    }
    for (auto& kv: distributionsWeights)
    {
        auto distribution = std::discrete_distribution<uint8_t>(kv.second.begin(), kv.second.end());
        m_instructionsWeights[kv.first] = distribution;
    }
}

void ProgramGenerator::addInstruction(Program& program, Instruction instruction)
{
    auto opCode = static_cast<uint8_t>(instruction);
    auto push1Opcode = static_cast<uint8_t>(Instruction::PUSH1);
    auto pInstruction = std::make_shared<ProgramInstruction>(instruction);
    if (opCode >= push1Opcode && opCode <= static_cast<uint8_t>(Instruction::PUSH32))
    {
        auto operandSize = opCode - push1Opcode + 1;
        auto operand = m_u256Generator() % operandSize;
        if (operandSize < 32)
        {
            u256 maxValue = u256(1) << (operandSize * 8) - 1;
            operand %= maxValue;
        }
        ProgramData programData(operand, operandSize);
        pInstruction = std::make_shared<ProgramInstructionWithData>(instruction, programData);
    }
    program.addInstruction(pInstruction);
}

Program ProgramGenerator::generateInitialProgram(uint64_t programSize)
{
    Program program;

    for (uint64_t i = 0; i < programSize; i++)
    {
        auto stackSize = program.stackSize();
        auto& availableInstructions = m_instructionsPerArgsCount[stackSize];
        auto& distribution = m_instructionsWeights[stackSize];
        auto instruction = availableInstructions[distribution(m_generator)];
        addInstruction(program, instruction);
    }

    return program;
}

}
}
