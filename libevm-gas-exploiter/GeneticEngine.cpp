#include "GeneticEngine.h"
#include "Benchmarker.h"


namespace dev
{
namespace eth
{

GeneticEngine::GeneticEngine(Config config, std::unique_ptr<ProgramGenerator> programGenerator)
  : m_config(config),
    m_programGenerator(std::move(programGenerator)),
    m_generator(std::default_random_engine(config.seed))
{
    for (size_t i = 0; i < config.populationSize; i++)
    {
        auto program = m_programGenerator->generateInitialProgram(config.initialProgramSize);
        EvaluatedProgram evaluatedProgram = EvaluatedProgram { .program = program, .evaluation = boost::none };
        m_population.push_back(evaluatedProgram);
    }
}

void GeneticEngine::run()
{
    for (uint32_t i = 0; i < m_config.generationsCount; i++)
    {
        advanceGeneration();
    }
}

void GeneticEngine::advanceGeneration()
{
    auto stats = computeFitness();
    m_stats.push_back(stats);
}

GeneticEngine::Stats GeneticEngine::computeFitness()
{
    double sumThroughput = 0.0;
    double minThroughput = 0.0;

    for (auto& eProgram : m_population)
    {
        if (eProgram.evaluation.is_initialized())
        {
            continue;
        }
        if (m_config.debug)
        {
            std::cout << eProgram.program.toHex() << std::endl;
        }
        auto result = benchmarkCode(m_config.execEnv, eProgram.program.toBytes(),
            m_config.benchmarkExecCount, m_config.debug);
        eProgram.evaluation = result;
        auto throughput = result.gasPerSecond;
        if (throughput < minThroughput)
        {
            minThroughput = throughput;
        }
        sumThroughput += throughput;
    }
    return Stats {
        .generationNumber = m_stats.size(),
        .minThroughput = minThroughput,
        .averageThroughput = sumThroughput / m_population.size()
    };
}


}  // namespace eth
}  // namespace dev
