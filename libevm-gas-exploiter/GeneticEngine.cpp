#include "GeneticEngine.h"
#include "Benchmarker.h"
#include "Utils.h"


namespace dev
{
namespace eth
{

GeneticEngine::GeneticEngine(Config config, std::shared_ptr<ProgramGenerator> programGenerator)
  : m_config(config),
    m_programGenerator(programGenerator),
    m_generator(std::default_random_engine(config.seed))
{
    for (size_t i = 0; i < config.populationSize; i++)
    {
        auto program = m_programGenerator->generateInitialProgram(config.initialProgramSize);
        auto evaluatedProgram = std::make_shared<EvaluatedProgram>(program);
        m_population.push_back(evaluatedProgram);
    }
}

void GeneticEngine::run()
{
    for (uint32_t i = 0; i < m_config.generationsCount; i++)
    {
        advanceGeneration();
    }
}

void GeneticEngine::advanceGeneration()
{
    auto stats = computeFitness();
    m_stats.push_back(stats);
}

std::shared_ptr<GeneticEngine::EvaluatedProgram> GeneticEngine::tournamentSelection(
    const std::vector<std::shared_ptr<EvaluatedProgram>>& population,
    GeneticEngine::TournamentSelectionConfig config)
{
    size_t k = std::ceil(config.sampleRatio * population.size());
    std::vector<int> indexes(population.size());
    std::iota(indexes.begin(), indexes.end(), 0);
    std::shuffle(indexes.begin(), indexes.end(), m_generator);

    std::vector<std::shared_ptr<EvaluatedProgram>> candidates;
    for (size_t i = 0; i < k; i++)
    {
        auto index = indexes[i];
        candidates.push_back(population[index]);
    }

    auto sortFunction = [](std::shared_ptr<EvaluatedProgram> left,
                            std::shared_ptr<EvaluatedProgram> right) -> bool {
        return left->evaluation->gasPerSecond < right->evaluation->gasPerSecond;
    };
    std::sort(candidates.begin(), candidates.end(), sortFunction);

    std::vector<double> weights;
    auto p = config.prob;
    for (size_t i = 0; i < k; i++)
    {
        auto weight = std::pow(p * (1 - p), i);
        weights.push_back(weight);
    }
    std::discrete_distribution<size_t> distrib(weights.begin(), weights.end());
    auto index = distrib(m_generator);
    return candidates[index];
}

GeneticEngine::Stats GeneticEngine::computeFitness()
{
    double sumThroughput = 0.0;
    double minThroughput = 0.0;

    for (auto& eProgram : m_population)
    {
        if (eProgram->evaluation.is_initialized())
        {
            continue;
        }
        if (m_config.debug)
        {
            std::cout << eProgram->program.toHex() << std::endl;
        }
        auto result = benchmarkCode(m_config.execEnv, eProgram->program.toBytes(),
            m_config.benchmarkExecCount, m_config.debug);
        eProgram->evaluation = result;
        auto throughput = result.gasPerSecond;
        if (throughput < minThroughput)
        {
            minThroughput = throughput;
        }
        sumThroughput += throughput;
    }
    return Stats {
        .generationNumber = m_stats.size(),
        .minThroughput = minThroughput,
        .averageThroughput = sumThroughput / m_population.size()
    };
}

void GeneticEngine::appendProgram(Program& child, const Program& parent,
                                  const std::vector<size_t>& stackCandidates,
                                  bool useTail)
{
    std::uniform_int_distribution<size_t> progDist(0, stackCandidates.size() - 1);
    auto progSplitPoint = stackCandidates[progDist(m_generator)];
    auto& instructions = parent.instructions();
    size_t start = 0;
    size_t end = progSplitPoint;
    if (useTail)
    {
        start = progSplitPoint;
        end = instructions.size();
    }

    for (size_t i = start; i < end; i++)
    {
        child.addInstruction(instructions[i]);
    }
}

Program GeneticEngine::crossOver(const Program& prog, const Program& other)
{
    auto progStackIndex = prog.stackSizeReverseIndex();
    auto otherStackIndex = other.stackSizeReverseIndex();

    auto stackSizesCandidates = keyIntersection(progStackIndex, otherStackIndex);
    std::vector<uint64_t> weights;
    for (auto stackSize : stackSizesCandidates)
    {
        weights.push_back(progStackIndex[stackSize].size() + otherStackIndex[stackSize].size());
    }
    std::discrete_distribution<size_t> distribution(weights.begin(), weights.end());
    auto stackSizeIndex = distribution(m_generator);

    auto splitStackSize = stackSizesCandidates[stackSizeIndex];

    Program child;

    appendProgram(child, prog, progStackIndex[splitStackSize], false);
    appendProgram(child, other, otherStackIndex[splitStackSize], true);

    return child;
}

}  // namespace eth
}  // namespace dev
