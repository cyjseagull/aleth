#include "GeneticEngine.h"
#include "Benchmarker.h"
#include "Utils.h"


namespace dev
{
namespace eth
{

Json::Value GeneticEngine::Stats::toJson() const
{
    Json::Value result;
    result["generationNumber"] = generationNumber();
    result["averageThroughput"] = averageThroughput();
    result["bestProgram"] = m_bestProgram->toJson();
    return result;
}

Json::Value GeneticEngine::EvaluatedProgram::toJson() const
{
    Json::Value result;
    result["throughput"] = evaluation->gasPerSecond;
    result["gas"] = evaluation->gas;
    result["time"] = evaluation->timeMean;
    result["code"] = program.toHex();
    result["size"] = program.size();
    result["uniqueSize"] = program.uniqueSize();
    return result;
}

GeneticEngine::GeneticEngine(Config config, std::shared_ptr<ProgramGenerator> programGenerator,
    std::ostream& statsOutputStream)
  : m_config(config),
    m_programGenerator(programGenerator),
    m_statsOutputStream(statsOutputStream),
    m_generator(std::default_random_engine(config.seed))
{
    for (size_t i = 0; i < config.populationSize; i++)
    {
        auto program = m_programGenerator->generateInitialProgram(config.initialProgramSize);
        auto evaluatedProgram = std::make_shared<EvaluatedProgram>(program);
        m_population.push_back(evaluatedProgram);
    }
}

void GeneticEngine::run()
{
    Json::StreamWriterBuilder builder;
    builder.settings_["indentation"] = "";
    std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());

    for (uint32_t i = 0; i < m_config.generationsCount; i++)
    {
        advanceGeneration();

        auto& latestStats = m_stats[m_stats.size() - 1];
        auto json = latestStats.toJson();
        writer->write(json, &m_statsOutputStream);
        m_statsOutputStream << std::endl;
    }
}

void GeneticEngine::advanceGeneration()
{
    auto stats = computeFitness();
    m_stats.push_back(stats);

    std::sort(m_population.begin(), m_population.end(), comparePrograms);

    size_t eliteCount = std::floor(m_population.size() * m_config.eliteRatio);

    std::vector<std::shared_ptr<EvaluatedProgram>> newPopulation;
    for (size_t i = 0; i < eliteCount; i++)
    {
        newPopulation.push_back(m_population[i]);
    }

    for (size_t i = eliteCount; i < m_config.populationSize; i++)
    {
        auto parent1 = tournamentSelection();
        auto parent2 = tournamentSelection();
        auto childProgram = crossOver(parent1->program, parent2->program);
        auto child = std::make_shared<EvaluatedProgram>(childProgram);
        newPopulation.push_back(child);
    }

    m_population = newPopulation;
}

std::shared_ptr<GeneticEngine::EvaluatedProgram> GeneticEngine::tournamentSelection(
    const std::vector<std::shared_ptr<EvaluatedProgram>>& population,
    GeneticEngine::TournamentSelectionConfig config)
{
    size_t k = std::ceil(config.sampleRatio * population.size());
    std::vector<int> indexes(population.size());
    std::iota(indexes.begin(), indexes.end(), 0);
    std::shuffle(indexes.begin(), indexes.end(), m_generator);

    std::vector<std::shared_ptr<EvaluatedProgram>> candidates;
    for (size_t i = 0; i < k; i++)
    {
        auto index = indexes[i];
        candidates.push_back(population[index]);
    }

    std::sort(candidates.begin(), candidates.end(), comparePrograms);

    std::vector<double> weights;
    auto p = config.prob;
    for (size_t i = 0; i < k; i++)
    {
        auto weight = std::pow(p * (1 - p), i);
        weights.push_back(weight);
    }
    std::discrete_distribution<size_t> distrib(weights.begin(), weights.end());
    auto index = distrib(m_generator);
    return candidates[index];
}

GeneticEngine::Stats GeneticEngine::computeFitness()
{
    double sumThroughput = 0.0;
    std::shared_ptr<EvaluatedProgram> bestProgram = nullptr;

    for (auto eProgram : m_population)
    {
        if (!eProgram->evaluation.is_initialized())
        {
            if (m_config.debug)
            {
                std::cout << eProgram->program.toHex() << std::endl;
            }
            auto result = benchmarkCode(m_config.execEnv, eProgram->program.toBytes(),
                m_config.benchmarkExecCount, m_config.debug);
            eProgram->evaluation = result;
        }
        auto throughput = eProgram->evaluation->gasPerSecond;
        if (bestProgram == nullptr || throughput < bestProgram->evaluation->gasPerSecond)
        {
            bestProgram = eProgram;
        }
        sumThroughput += throughput;
    }
    return Stats(m_stats.size(), sumThroughput / m_population.size(), bestProgram);
}

void GeneticEngine::appendProgram(Program& child, const Program& parent,
                                  const std::vector<size_t>& stackCandidates,
                                  bool useTail)
{
    std::uniform_int_distribution<size_t> progDist(0, stackCandidates.size() - 1);
    auto progSplitPoint = stackCandidates[progDist(m_generator)];
    auto& instructions = parent.instructions();
    size_t start = 0;
    size_t end = progSplitPoint;
    if (useTail)
    {
        start = progSplitPoint;
        end = instructions.size();
    }

    for (size_t i = start; i < end; i++)
    {
        child.addInstruction(instructions[i]);
    }
}

Program GeneticEngine::crossOver(const Program& prog, const Program& other)
{
    auto progStackIndex = prog.stackSizeReverseIndex();
    auto otherStackIndex = other.stackSizeReverseIndex();

    auto stackSizesCandidates = keyIntersection(progStackIndex, otherStackIndex);
    std::vector<uint64_t> weights;
    for (auto stackSize : stackSizesCandidates)
    {
        weights.push_back(progStackIndex[stackSize].size() + otherStackIndex[stackSize].size());
    }
    std::discrete_distribution<size_t> distribution(weights.begin(), weights.end());
    auto stackSizeIndex = distribution(m_generator);

    auto splitStackSize = stackSizesCandidates[stackSizeIndex];

    Program child;

    appendProgram(child, prog, progStackIndex[splitStackSize], false);
    appendProgram(child, other, otherStackIndex[splitStackSize], true);

    child.extendSize(m_config.minimumProgramSize);

    return child;
}


void GeneticEngine::outputBest(size_t k, std::ostream& stream)
{
    std::sort(m_population.begin(), m_population.end(), comparePrograms);

    Json::StreamWriterBuilder builder;
    builder.settings_["indentation"] = "";
    std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());

    for (size_t i = 0; i < k; i++)
    {
        auto& eProgram = m_population[i];
        writer->write(eProgram->toJson(), &stream);
        stream << std::endl;
    }
}

}  // namespace eth
}  // namespace dev
