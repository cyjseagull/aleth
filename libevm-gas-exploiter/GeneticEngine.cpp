#include "GeneticEngine.h"
#include "Benchmarker.h"
#include "InstructionGenerator.h"
#include "Utils.h"

#include <csignal>


namespace dev
{
namespace eth
{


namespace
{
static bool handlerInstalled = false;
static bool shouldStop = false;
static bool stopping = false;

void signalHandler(int)
{
    if (stopping)
    {
        exit(1);
    }
    else
    {
        shouldStop = true;
        stopping = true;
    }
}

void installHandler()
{
    if (!handlerInstalled)
    {
        signal(SIGINT, signalHandler);
        handlerInstalled = true;
    }
}
}

Json::Value GeneticEngine::Stats::toJson() const
{
    Json::Value result;
    result["generationNumber"] = generationNumber();
    result["averageThroughput"] = averageThroughput();
    result["bestProgram"] = m_bestProgram.toJson();
    return result;
}

Json::Value GeneticEngine::EvaluatedProgram::toJson() const
{
    Json::Value result;
    result["evaluation"] = evaluation->toJson();
    result["program"] = Json::Value();
    result["program"]["code"] = program.toHex();
    result["program"]["size"] = program.size();
    result["program"]["uniqueSize"] = program.uniqueSize();
    return result;
}

GeneticEngine::GeneticEngine(Config config, std::shared_ptr<ProgramGenerator> programGenerator,
    std::ostream& statsOutputStream)
  : m_config(config),
    m_programGenerator(programGenerator),
    m_statsOutputStream(statsOutputStream),
    m_generator(std::default_random_engine(config.seed))
{
    installHandler();
    for (size_t i = 0; i < config.populationSize; i++)
    {
        auto program = m_programGenerator->generateInitialProgram(config.initialProgramSize);
        auto evaluatedProgram = std::make_shared<EvaluatedProgram>(program);
        m_population.push_back(evaluatedProgram);
    }
}

void GeneticEngine::run()
{
    Json::StreamWriterBuilder builder;
    builder.settings_["indentation"] = "";
    std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());

    for (uint32_t i = 0; !shouldStop && i < m_config.generationsCount; i++)
    {
        advanceGeneration();

        auto& latestStats = m_stats[m_stats.size() - 1];
        auto json = latestStats.toJson();
        writer->write(json, &m_statsOutputStream);
        m_statsOutputStream << std::endl;
    }
}

void GeneticEngine::advanceGeneration()
{
    auto stats = computeFitness();
    m_stats.push_back(stats);

    std::sort(m_population.begin(), m_population.end(), comparePrograms());

    size_t eliteCount = std::floor(m_population.size() * m_config.eliteRatio);

    std::vector<std::shared_ptr<EvaluatedProgram>> newPopulation;
    for (size_t i = 0; i < eliteCount; i++)
    {
        newPopulation.push_back(m_population[i]);
    }

    for (size_t i = eliteCount; i < m_config.populationSize; i++)
    {
        auto parent1 = tournamentSelection();
        auto parent2 = tournamentSelection();
        Program child1;
        Program child2;
        std::tie(child1, child2) = crossOver(parent1->program, parent2->program);
        mutate(child1, m_config.mutationsCount);
        mutate(child2, m_config.mutationsCount);

        auto childProgram1 = std::make_shared<EvaluatedProgram>(child1);
        newPopulation.push_back(childProgram1);
        auto childProgram2 = std::make_shared<EvaluatedProgram>(child2);
        newPopulation.push_back(childProgram2);
    }

    m_population = newPopulation;
}

std::shared_ptr<GeneticEngine::EvaluatedProgram> GeneticEngine::tournamentSelection(
    const std::vector<std::shared_ptr<EvaluatedProgram>>& population,
    GeneticEngine::TournamentSelectionConfig config)
{
    size_t k = std::ceil(config.sampleRatio * population.size());
    std::vector<int> indexes(population.size());
    std::iota(indexes.begin(), indexes.end(), 0);
    std::shuffle(indexes.begin(), indexes.end(), m_generator);

    std::vector<std::shared_ptr<EvaluatedProgram>> candidates;
    for (size_t i = 0; i < population.size() && candidates.size() < k; i++)
    {
        auto index = indexes[i];
        if (population[index]->evaluation.is_initialized())
        {
            candidates.push_back(population[index]);
        }
    }

    std::sort(candidates.begin(), candidates.end(), comparePrograms());

    std::vector<double> weights;
    auto p = config.prob;
    for (size_t i = 0; i < k; i++)
    {
        auto weight = std::pow(p * (1 - p), i);
        weights.push_back(weight);
    }
    std::discrete_distribution<size_t> distrib(weights.begin(), weights.end());
    auto index = distrib(m_generator);
    return candidates[index];
}

double GeneticEngine::getThroughput(const ExecutionAggregatedStats& stats)
{
    switch (m_config.targetMetric)
    {
        case Metric::Mean:
            return stats.gasPerSecond;
        case Metric::Median:
            return stats.medianGasPerSecond;
        default:
            throw std::invalid_argument("invalid metric");
    }
}

void GeneticEngine::evalOrReplace(std::shared_ptr<GeneticEngine::EvaluatedProgram> eProgram)
{
    do
    {
        try
        {
            auto result = benchmarkCode(m_config.execEnv, eProgram->program.toBytes(),
                m_config.benchmarkConfig);
            eProgram->evaluation = result;
        }
        catch (const std::exception& e)
        {
            // If the execution failed, the generated program was invalid
            // most likely because the stack was too big
            // for now, just create a fresh and valid program instead
            eProgram->program = m_programGenerator->generateInitialProgram(m_config.initialProgramSize);
            LOG(m_logger) << "benchmark failed: " << e.what();
        }
    } while (!eProgram->evaluation.is_initialized());
}


GeneticEngine::Stats GeneticEngine::computeFitness()
{
    double sumThroughput = 0.0;
    size_t totalValid = 0;
    std::shared_ptr<EvaluatedProgram> bestProgram = nullptr;

    for (auto eProgram : m_population)
    {
        if (!eProgram->evaluation.is_initialized() || !m_config.cacheResults)
        {
            if (m_config.debug)
            {
                std::cout << eProgram->program.toHex() << std::endl;
            }
            evalOrReplace(eProgram);
        }
        auto throughput = getThroughput(*eProgram->evaluation);
        if (bestProgram == nullptr || throughput < getThroughput(*bestProgram->evaluation))
        {
            bestProgram = eProgram;
        }
        sumThroughput += throughput;
        totalValid++;
    }
    return Stats(m_stats.size(), sumThroughput / totalValid,
                 getThroughput(*bestProgram->evaluation), *bestProgram);
}

void GeneticEngine::appendProgram(Program& child, const Program& parent,
                                  size_t progSplitPoint, bool useTail)
{
    auto& instructions = parent.instructions();
    size_t start = 0;
    size_t end = progSplitPoint;
    if (useTail)
    {
        start = progSplitPoint;
        end = instructions.size();
    }

    for (size_t i = start; i < end; i++)
    {
        child.addInstruction(instructions[i]);
    }
}

std::pair<Program, Program> GeneticEngine::crossOver(const Program& prog, const Program& other)
{
    auto progStackIndex = prog.stackSizeReverseIndex();
    auto otherStackIndex = other.stackSizeReverseIndex();

    auto stackSizesCandidates = keyIntersection(progStackIndex, otherStackIndex);
    std::vector<uint64_t> weights;
    for (auto stackSize : stackSizesCandidates)
    {
        weights.push_back(progStackIndex[stackSize].size() + otherStackIndex[stackSize].size());
    }
    std::discrete_distribution<size_t> distribution(weights.begin(), weights.end());
    auto stackSizeIndex = distribution(m_generator);

    auto splitStackSize = stackSizesCandidates[stackSizeIndex];


    std::uniform_int_distribution<size_t> progDist(0, progStackIndex[splitStackSize].size() - 1);
    auto progSplitPoint = progStackIndex[splitStackSize][progDist(m_generator)];
    std::uniform_int_distribution<size_t> otherDist(0, otherStackIndex[splitStackSize].size() - 1);
    auto otherSplitPoint = otherStackIndex[splitStackSize][otherDist(m_generator)];

    Program child1;
    appendProgram(child1, prog, progSplitPoint, false);
    appendProgram(child1, other, otherSplitPoint, true);
    child1.extendSize(m_config.minimumProgramSize);

    Program child2;
    appendProgram(child2, other, otherSplitPoint, false);
    appendProgram(child2, prog, progSplitPoint, true);
    child2.extendSize(m_config.minimumProgramSize);

    return std::make_pair(child1, child2);
}


void GeneticEngine::mutate(Program& program, size_t n)
{
    for (size_t i = 0; i < n; i++)
    {
        mutateOnce(program);
    }
}

void GeneticEngine::mutateOnce(Program& program)
{
    std::uniform_int_distribution<int> indexDistribution(0 , program.size() - 1);
    auto indexToChange = indexDistribution(m_generator);
    auto instructionToChange = program[indexToChange];

    // If the instruction is a PUSH or POP required by an instruction
    // find the actual instruction
    if (instructionToChange->requiredBy() != nullptr)
    {
        for (size_t i = indexToChange + 1; i < program.size(); i++)
        {
            if (program[i] == instructionToChange->requiredBy())
            {
                indexToChange = i;
                instructionToChange = program[i];
                break;
            }
        }
    }

    auto instrInfo = instructionInfo(instructionToChange->instruction());
    std::vector<Instruction> candidates;
    for (auto instr : programGenerator()->instructionsPerArgsCount(instrInfo.args))
    {
        if (instructionInfo(instr).ret - instructionInfo(instr).args >= instrInfo.ret - instrInfo.args)
        {
            candidates.push_back(instr);
        }
    }
    std::uniform_int_distribution<int> candidateIndexDistribution(0 , candidates.size() - 1);
    auto newInstr = candidates[candidateIndexDistribution(m_generator)];
    auto newPInstr = m_programGenerator->makeInstruction(newInstr);
    auto replacementSequence = generateMemorySafeSequence(newPInstr, m_generator);
    program.replaceInstruction(indexToChange, replacementSequence);
}

void GeneticEngine::outputBest(size_t k, std::ostream& stream)
{
    computeFitness();
    std::sort(m_population.begin(), m_population.end(), comparePrograms());

    Json::StreamWriterBuilder builder;
    builder.settings_["indentation"] = "";
    std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());

    for (size_t i = 0; i < k; i++)
    {
        auto& eProgram = m_population[i];
        writer->write(eProgram->toJson(), &stream);
        stream << std::endl;
    }
}

}  // namespace eth
}  // namespace dev
