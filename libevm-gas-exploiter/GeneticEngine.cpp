#include "GeneticEngine.h"
#include "Benchmarker.h"
#include "Utils.h"


namespace dev
{
namespace eth
{

GeneticEngine::GeneticEngine(Config config, std::shared_ptr<ProgramGenerator> programGenerator)
  : m_config(config),
    m_programGenerator(programGenerator),
    m_generator(std::default_random_engine(config.seed))
{
    for (size_t i = 0; i < config.populationSize; i++)
    {
        auto program = m_programGenerator->generateInitialProgram(config.initialProgramSize);
        EvaluatedProgram evaluatedProgram = EvaluatedProgram { .program = program, .evaluation = boost::none };
        m_population.push_back(evaluatedProgram);
    }
}

void GeneticEngine::run()
{
    for (uint32_t i = 0; i < m_config.generationsCount; i++)
    {
        advanceGeneration();
    }
}

void GeneticEngine::advanceGeneration()
{
    auto stats = computeFitness();
    m_stats.push_back(stats);
}

GeneticEngine::Stats GeneticEngine::computeFitness()
{
    double sumThroughput = 0.0;
    double minThroughput = 0.0;

    for (auto& eProgram : m_population)
    {
        if (eProgram.evaluation.is_initialized())
        {
            continue;
        }
        if (m_config.debug)
        {
            std::cout << eProgram.program.toHex() << std::endl;
        }
        auto result = benchmarkCode(m_config.execEnv, eProgram.program.toBytes(),
            m_config.benchmarkExecCount, m_config.debug);
        eProgram.evaluation = result;
        auto throughput = result.gasPerSecond;
        if (throughput < minThroughput)
        {
            minThroughput = throughput;
        }
        sumThroughput += throughput;
    }
    return Stats {
        .generationNumber = m_stats.size(),
        .minThroughput = minThroughput,
        .averageThroughput = sumThroughput / m_population.size()
    };
}

void GeneticEngine::appendProgram(Program& child, const Program& parent,
                                  const std::vector<size_t>& stackCandidates,
                                  bool useTail)
{
    std::uniform_int_distribution<size_t> progDist(0, stackCandidates.size() - 1);
    auto progSplitPoint = stackCandidates[progDist(m_generator)];
    auto& instructions = parent.instructions();
    size_t start = 0;
    size_t end = progSplitPoint;
    if (useTail)
    {
        start = progSplitPoint;
        end = instructions.size();
    }

    for (size_t i = start; i < end; i++)
    {
        child.addInstruction(instructions[i]);
    }
}

Program GeneticEngine::crossOver(const Program& prog, const Program& other)
{
    auto progStackIndex = prog.stackSizeReverseIndex();
    auto otherStackIndex = other.stackSizeReverseIndex();

    auto stackSizesCandidates = keyIntersection(progStackIndex, otherStackIndex);
    std::vector<uint64_t> weights;
    for (auto stackSize : stackSizesCandidates)
    {
        weights.push_back(progStackIndex[stackSize].size() + otherStackIndex[stackSize].size());
    }
    std::discrete_distribution<size_t> distribution(weights.begin(), weights.end());
    auto stackSizeIndex = distribution(m_generator);

    auto splitStackSize = stackSizesCandidates[stackSizeIndex];

    Program child;

    appendProgram(child, prog, progStackIndex[splitStackSize], false);
    appendProgram(child, other, otherStackIndex[splitStackSize], true);

    return child;
}

}  // namespace eth
}  // namespace dev
