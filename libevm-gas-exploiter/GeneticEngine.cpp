#include "GeneticEngine.h"
#include "Benchmarker.h"
#include "InstructionGenerator.h"
#include "Utils.h"

#include <csignal>


namespace dev
{
namespace eth
{


namespace
{
static volatile bool handlerInstalled = false;
static volatile bool shouldStop = false;
static volatile bool stopping = false;

void signalHandler(int)
{
    if (stopping)
    {
        std::cerr << "SIGINT signal received again, forcing shutdown" << std::endl;
        exit(1);
    }
    else
    {
        shouldStop = true;
        stopping = true;
        std::cerr << "SIGINT signal received, shutting down. This might take a moment..." << std::endl;
    }
}

void installHandler()
{
    if (!handlerInstalled)
    {
        signal(SIGINT, signalHandler);
        handlerInstalled = true;
    }
}
}

Json::Value GeneticEngine::Stats::toJson() const
{
    Json::Value result;
    result["generationNumber"] = generationNumber();
    result["bestProgram"] = m_bestProgram.toJson();
    result["results"] = m_benchmarkStats.toJson();
    return result;
}

Json::Value GeneticEngine::Stats::toJson(
    const std::vector<std::shared_ptr<EvaluatedProgram>>& population) const
{
    Json::Value result = toJson();
    result["programs"] = Json::Value(Json::arrayValue);
    for (const auto& eProgram : population)
    {
        result["programs"].append(eProgram->toJson(true));
    }
    return result;
}


Json::Value GeneticEngine::EvaluatedProgram::toJson(bool verbose) const
{
    Json::Value result;
    result["evaluation"] = evaluation->toJson();
    result["program"] = Json::Value();
    result["program"]["size"] = program.size();
    result["program"]["uniqueSize"] = program.uniqueSize();
    if (verbose)
    {
        result["program"]["code"] = program.toHex();
    }
    return result;
}

GeneticEngine::GeneticEngine(
    Config config, std::shared_ptr<ProgramGenerator> programGenerator, std::ostream& outputStream)
  : m_config(config),
    m_programGenerator(programGenerator),
    m_outputStream(outputStream),
    m_generator(std::default_random_engine(config.seed))
{
    installHandler();

    Json::StreamWriterBuilder builder;
    builder.settings_["indentation"] = "";
    m_jsonWriter = std::unique_ptr<Json::StreamWriter>(builder.newStreamWriter());

    for (size_t i = 0; i < config.populationSize; i++)
    {
        auto program = m_programGenerator->generateInitialProgram(config.initialProgramSize);
        auto evaluatedProgram = std::make_shared<EvaluatedProgram>(program);
        m_population.push_back(evaluatedProgram);
    }
}

std::function<bool(std::shared_ptr<GeneticEngine::EvaluatedProgram>,
    std::shared_ptr<GeneticEngine::EvaluatedProgram>)>
GeneticEngine::comparePrograms()
{
    const auto& config = m_config;
    return [&config](std::shared_ptr<EvaluatedProgram> left,
               std::shared_ptr<EvaluatedProgram> right) -> bool {
        if (!left->evaluation.is_initialized())
        {
            return false;
        }
        else if (!right->evaluation.is_initialized())
        {
            return true;
        }
        switch (config.targetMetric)
        {
        case Metric::Median:
            return left->evaluation->medianGasPerSecond < right->evaluation->medianGasPerSecond;
        case Metric::Mean:
            return left->evaluation->gasPerSecond < right->evaluation->gasPerSecond;
        default:
            return false;
        }
    };
}

void GeneticEngine::run()
{
    for (uint32_t i = 0; !shouldStop && i < m_config.generationsCount; i++)
    {
        advanceGeneration();
    }
}


void GeneticEngine::advanceGeneration()
{
    auto stats = computeFitness();
    m_stats.push_back(stats);

    outputStats(stats);

    std::sort(m_population.begin(), m_population.end(), comparePrograms());

    size_t eliteCount = std::floor(m_population.size() * m_config.eliteRatio);

    std::vector<std::shared_ptr<EvaluatedProgram>> newPopulation;
    for (size_t i = 0; i < eliteCount; i++)
    {
        newPopulation.push_back(m_population[i]);
    }

    for (size_t i = eliteCount; i < m_config.populationSize; i++)
    {
        auto parent1 = tournamentSelection();
        auto parent2 = tournamentSelection();
        Program child1;
        Program child2;
        std::tie(child1, child2) = crossOver(parent1->program, parent2->program);
        mutate(child1, m_config.mutationsCount);
        mutate(child2, m_config.mutationsCount);

        auto childProgram1 = std::make_shared<EvaluatedProgram>(child1);
        newPopulation.push_back(childProgram1);
        auto childProgram2 = std::make_shared<EvaluatedProgram>(child2);
        newPopulation.push_back(childProgram2);
    }

    m_population = newPopulation;
}

void GeneticEngine::outputStats(const GeneticEngine::Stats& stats) const
{
    auto json = stats.toJson(m_population);
    m_jsonWriter->write(json, &m_outputStream);
    m_outputStream << std::endl;
}

std::shared_ptr<GeneticEngine::EvaluatedProgram> GeneticEngine::tournamentSelection(
    const std::vector<std::shared_ptr<EvaluatedProgram>>& population,
    GeneticEngine::TournamentSelectionConfig config)
{
    size_t k = std::ceil(config.sampleRatio * population.size());
    std::vector<int> indexes(population.size());
    std::iota(indexes.begin(), indexes.end(), 0);
    std::shuffle(indexes.begin(), indexes.end(), m_generator);

    std::vector<std::shared_ptr<EvaluatedProgram>> candidates;
    for (size_t i = 0; i < population.size() && candidates.size() < k; i++)
    {
        auto index = indexes[i];
        if (population[index]->evaluation.is_initialized())
        {
            candidates.push_back(population[index]);
        }
    }

    std::sort(candidates.begin(), candidates.end(), comparePrograms());

    std::vector<double> weights;
    auto p = config.prob;
    for (size_t i = 0; i < k; i++)
    {
        auto weight = std::pow(p * (1 - p), i);
        weights.push_back(weight);
    }
    std::discrete_distribution<size_t> distrib(weights.begin(), weights.end());
    auto index = distrib(m_generator);
    return candidates[index];
}

double GeneticEngine::getThroughput(const ExecutionAggregatedStats& stats)
{
    switch (m_config.targetMetric)
    {
        case Metric::Mean:
            return stats.gasPerSecond;
        case Metric::Median:
            return stats.medianGasPerSecond;
        default:
            throw std::invalid_argument("invalid metric");
    }
}


GeneticEngine::Stats GeneticEngine::computeFitness()
{
    std::shared_ptr<EvaluatedProgram> bestProgram = nullptr;

    std::vector<bytes> codes;
    for (auto eProgram : m_population)
    {
        if (m_config.debug)
        {
            std::cout << eProgram->program.toHex() << std::endl;
        }
        codes.push_back(eProgram->program.toBytes());
    }

    auto results = benchmarkCodes(m_config.execEnv, codes, m_config.benchmarkConfig);

    for (size_t i = 0; i < m_population.size(); i++)
    {
        auto eProgram = m_population[i];
        if (!eProgram->evaluation.is_initialized() || !m_config.cacheResults)
        {
            eProgram->evaluation = results.programStats[i];
        }

        auto throughput = getThroughput(*eProgram->evaluation);
        if (bestProgram == nullptr || throughput < getThroughput(*bestProgram->evaluation))
        {
            bestProgram = eProgram;
        }
    }

    return Stats(m_stats.size(), getThroughput(*bestProgram->evaluation), *bestProgram, results);
}

void GeneticEngine::appendProgram(Program& child, const Program& parent,
                                  size_t progSplitPoint, bool useTail)
{
    auto& instructions = parent.instructions();
    size_t start = 0;
    size_t end = progSplitPoint;
    if (useTail)
    {
        start = progSplitPoint;
        end = instructions.size();
    }

    for (size_t i = start; i < end; i++)
    {
        child.addInstruction(instructions[i]);
    }
}

std::pair<Program, Program> GeneticEngine::crossOver(const Program& prog, const Program& other)
{
    auto progStackIndex = prog.stackSizeReverseIndex();
    auto otherStackIndex = other.stackSizeReverseIndex();

    auto stackSizesCandidates = keyIntersection(progStackIndex, otherStackIndex);
    std::vector<uint64_t> weights;
    for (auto stackSize : stackSizesCandidates)
    {
        weights.push_back(progStackIndex[stackSize].size() + otherStackIndex[stackSize].size());
    }
    std::discrete_distribution<size_t> distribution(weights.begin(), weights.end());
    auto stackSizeIndex = distribution(m_generator);

    auto splitStackSize = stackSizesCandidates[stackSizeIndex];


    std::uniform_int_distribution<size_t> progDist(0, progStackIndex[splitStackSize].size() - 1);
    auto progSplitPoint = progStackIndex[splitStackSize][progDist(m_generator)];
    std::uniform_int_distribution<size_t> otherDist(0, otherStackIndex[splitStackSize].size() - 1);
    auto otherSplitPoint = otherStackIndex[splitStackSize][otherDist(m_generator)];

    Program child1;
    appendProgram(child1, prog, progSplitPoint, false);
    appendProgram(child1, other, otherSplitPoint, true);
    child1.extendSize(m_config.minimumProgramSize);

    Program child2;
    appendProgram(child2, other, otherSplitPoint, false);
    appendProgram(child2, prog, progSplitPoint, true);
    child2.extendSize(m_config.minimumProgramSize);

    return std::make_pair(child1, child2);
}


void GeneticEngine::mutate(Program& program, size_t n)
{
    for (size_t i = 0; i < n; i++)
    {
        mutateOnce(program);
    }
}

void GeneticEngine::mutateOnce(Program& program)
{
    std::uniform_int_distribution<int> indexDistribution(0 , program.size() - 1);
    auto indexToChange = indexDistribution(m_generator);
    auto instructionToChange = program[indexToChange];

    // If the instruction is a PUSH or POP required by an instruction
    // find the actual instruction
    if (instructionToChange->requiredBy() != nullptr)
    {
        for (size_t i = indexToChange + 1; i < program.size(); i++)
        {
            if (program[i] == instructionToChange->requiredBy())
            {
                indexToChange = i;
                instructionToChange = program[i];
                break;
            }
        }
    }

    auto instrInfo = instructionInfo(instructionToChange->instruction());
    std::vector<Instruction> candidates;
    for (auto instr : programGenerator()->instructionsPerArgsCount(instrInfo.args))
    {
        if (instructionInfo(instr).ret - instructionInfo(instr).args == instrInfo.ret - instrInfo.args)
        {
            candidates.push_back(instr);
        }
    }
    std::uniform_int_distribution<int> candidateIndexDistribution(0 , candidates.size() - 1);
    auto newInstr = candidates[candidateIndexDistribution(m_generator)];
    auto newPInstr = m_programGenerator->makeInstruction(newInstr);
    auto replacementSequence = generateMemorySafeSequence(newPInstr, m_generator);
    program.replaceInstruction(indexToChange, replacementSequence);
}


}  // namespace eth
}  // namespace dev
