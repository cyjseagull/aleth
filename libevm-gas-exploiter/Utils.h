#pragma once

#include <algorithm>
#include <cmath>
#include <map>
#include <vector>
#include <chrono>

namespace dev
{

template<typename T, typename U>
std::vector<T> keyIntersection(std::map<T, U> first, std::map<T, U> second)
{
    std::vector<T> intersection;
    for (auto& kv : first)
    {
        if (second.find(kv.first) != second.end())
        {
            intersection.push_back(kv.first);
        }
    }
    return intersection;
}

class MillisecTimer
{
public:
    MillisecTimer() { restart(); }

    std::chrono::high_resolution_clock::duration duration() const { return std::chrono::high_resolution_clock::now() - m_t; }
    uint64_t elapsed() const { return std::chrono::duration_cast<std::chrono::milliseconds>(duration()).count(); }
    void restart() { m_t = std::chrono::high_resolution_clock::now(); }

private:
    std::chrono::high_resolution_clock::time_point m_t;
};


namespace math
{
template <typename It>
typename std::iterator_traits<It>::value_type sum(It first, It last)
{
    typename std::iterator_traits<It>::value_type result = {};
    for (auto&& elem = first; elem != last; elem++)
    {
        result += *elem;
    }
    return result;
}


template <typename It>
typename std::iterator_traits<It>::value_type mean(It first, It last)
{
    auto size = last - first;
    return sum(first, last) / size;
}

template <typename It>
typename std::iterator_traits<It>::value_type variance(It first, It last)
{
    typename std::iterator_traits<It>::value_type squaredSum = {};
    auto meanResult = mean(first, last);
    auto size = last - first;
    for (auto&& elem = first; elem != last; elem++)
    {
        auto value = *elem;
        squaredSum += value * value;
    }
    return (squaredSum / size) - (meanResult * meanResult);
}

template <typename It>
typename std::iterator_traits<It>::value_type stdev(It first, It last)
{
    return std::sqrt(variance(first, last));
}

template <typename It>
typename std::iterator_traits<It>::value_type median(It first, It last)
{
    std::sort(first, last);
    auto size = last - first;
    if (size % 2 == 1U)
    {
        return *(first + (size / 2U));
    }
    auto&& high = first + (size / 2U);
    auto&& low = first + (size / 2U - 1U);
    auto sum = *low + *high;
    return sum / 2;
}

template <typename It>
typename std::iterator_traits<It>::value_type constMedian(It first, It last)
{
    std::vector<typename std::iterator_traits<It>::value_type> v(first, last);
    return median(v.begin(), v.end());
}

}  // namespace math
}