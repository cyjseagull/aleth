#include "ProgramGeneratorHooks.h"

namespace
{
    const size_t minMemoryToUse = 1;
    const size_t maxMemoryToUse = 0xff;
    std::uniform_int_distribution<int> memoryLengthDistribution(minMemoryToUse , maxMemoryToUse);
}

namespace dev
{
namespace eth
{
using Protection = ProgramInstruction::Protection;

const std::map<std::string, std::shared_ptr<ProgramGeneratorHook>> availableHooks = {
    {"fix-memory", std::make_shared<FixMemoryHook>()},
    {"fix-log", std::make_shared<FixLogHook>()}
};


void FixMemoryHook::execute(
    Program& program, const std::shared_ptr<ProgramInstruction> inst, std::default_random_engine randEngine)
{
    switch (inst->instruction())
    {
    /// signature: CALLDATACOPY(destOffset, offset, length)
    ///            CODECOPY(destOffset, offset, length)
    /// stack before: x, y, z
    /// stack after:  destOffset, offset, length
    case Instruction::CALLDATACOPY:
    case Instruction::CODECOPY:
    {
        inst->enableProtection();
        auto memoryLength = memoryLengthDistribution(randEngine);
        auto offset = memoryLengthDistribution(randEngine);
        auto destOffset = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(
            Instruction::PUSH1, ProgramData(memoryLength, 1), Protection::Protected);
        program.addInstruction(Instruction::PUSH1, ProgramData(offset, 1), Protection::Protected);
        program.addInstruction(
            Instruction::PUSH1, ProgramData(destOffset, 1), Protection::Protected);
        break;
    }
    /// signature: MSTORE(offset, value)
    ///            MSTORE8(offset, value)
    /// stack before: x, y
    /// stack after:  offset, y
    case Instruction::MSTORE8:
    case Instruction::MSTORE:
    {
        inst->enableProtection();
        auto offset = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, ProgramData(offset, 1), Protection::Protected);
        break;
    }

    /// signature: SHA3(offset, length)
    /// stack before: x, y
    /// stack after:  offset, length
    case Instruction::SHA3:
    {
        inst->enableProtection();
        auto offset = memoryLengthDistribution(randEngine);
        auto length = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, ProgramData(length, 1), Protection::Protected);
        program.addInstruction(Instruction::PUSH1, ProgramData(offset, 1), Protection::Protected);
        break;
    }

    default:
        break;
    }
}

void FixLogHook::execute(
    Program& program, const std::shared_ptr<ProgramInstruction> inst, std::default_random_engine randEngine)
{
    switch (inst->instruction())
    {
    /// signature: LOG0(offset, length)
    ///            LOG1(offset, length, topic0)
    ///            LOG4(offset, length, topic0, topic1, topic2, topic3)
    /// stack before: x, y, topics...
    /// stack after:  offset, length, topics...
    case Instruction::LOG0:
    case Instruction::LOG1:
    case Instruction::LOG2:
    case Instruction::LOG3:
    case Instruction::LOG4:
    {
        inst->enableProtection();
        auto memoryLength = memoryLengthDistribution(randEngine);
        auto offsetLength = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(
            Instruction::PUSH1, ProgramData(memoryLength, 1), Protection::Protected);
        program.addInstruction(
            Instruction::PUSH1, ProgramData(offsetLength, 1), Protection::Protected);
        break;
    }

    default:
        break;
    }
}


}
}