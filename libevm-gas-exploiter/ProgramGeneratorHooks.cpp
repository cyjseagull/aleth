#include "ProgramGeneratorHooks.h"

namespace
{
    const size_t minMemoryToUse = 1;
    const size_t maxMemoryToUse = 0xff;
    std::uniform_int_distribution<int> memoryLengthDistribution(minMemoryToUse , maxMemoryToUse);
}

namespace dev
{
namespace eth
{
using Protection = ProgramInstruction::Protection;

const std::map<std::string, std::shared_ptr<ProgramGeneratorHook>> availableHooks = {
    {"fix-memory", std::make_shared<FixMemoryHook>()},
    {"fix-log", std::make_shared<FixLogHook>()}
};


void FixMemoryHook::execute(
    Program& program, const std::shared_ptr<ProgramInstruction> inst, std::default_random_engine randEngine)
{
    switch (inst->instruction())
    {
    /// signature: CALLDATACOPY(destOffset, offset, length)
    ///            CODECOPY(destOffset, offset, length)
    ///            RETURNDATACOPY(destOffset, offset, length)
    /// stack before: x, y, z
    /// stack after:  destOffset, offset, length
    case Instruction::CALLDATACOPY:
    case Instruction::CODECOPY:
    case Instruction::RETURNDATACOPY:
    {
        inst->enableProtection();
        auto memoryLength = memoryLengthDistribution(randEngine);
        auto offset = memoryLengthDistribution(randEngine);
        auto destOffset = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, memoryLength, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, offset, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, destOffset, Protection::Protected);
        break;
    }

    /// signature: MSTORE(offset, value)
    ///            MSTORE8(offset, value)
    /// stack before: x, y
    /// stack after:  offset, y
    case Instruction::MSTORE8:
    case Instruction::MSTORE:
    {
        inst->enableProtection();
        auto offset = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, offset, Protection::Protected);
        break;
    }

    /// signature: MLOAD(offset)
    /// stack before: x
    /// stack after:  offset
    case Instruction::MLOAD:
    {
        inst->enableProtection();
        auto offset = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, offset, Protection::Protected);
        break;
    }

    /// signature: SHA3(offset, length)
    /// stack before: x, y
    /// stack after:  offset, length
    case Instruction::SHA3:
    {
        inst->enableProtection();
        auto offset = memoryLengthDistribution(randEngine);
        auto length = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, length, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, offset, Protection::Protected);
        break;
    }

    /// signature: EXTCODECOPY(addr, destOffset, offset, length)
    /// stack before: a, b, c, d
    /// stack after: a, destOffset, offset, length
    case Instruction::EXTCODECOPY:
    {
        inst->enableProtection();
        auto memoryLength = memoryLengthDistribution(randEngine);
        auto offset = memoryLengthDistribution(randEngine);
        auto destOffset = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::SWAP3, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, memoryLength, Protection::Protected);
        program.addInstruction(Instruction::SWAP1, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, offset, Protection::Protected);
        program.addInstruction(Instruction::SWAP1, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, destOffset, Protection::Protected);
        program.addInstruction(Instruction::SWAP1, Protection::Protected);
        break;
    }

    default:
        break;
    }
}

void FixLogHook::execute(
    Program& program, const std::shared_ptr<ProgramInstruction> inst, std::default_random_engine randEngine)
{
    switch (inst->instruction())
    {
    /// signature: LOG0(offset, length)
    ///            LOG1(offset, length, topic0)
    ///            LOG4(offset, length, topic0, topic1, topic2, topic3)
    /// stack before: x, y, topics...
    /// stack after:  offset, length, topics...
    case Instruction::LOG0:
    case Instruction::LOG1:
    case Instruction::LOG2:
    case Instruction::LOG3:
    case Instruction::LOG4:
    {
        inst->enableProtection();
        auto memoryLength = memoryLengthDistribution(randEngine);
        auto offsetLength = memoryLengthDistribution(randEngine);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::POP, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, memoryLength, Protection::Protected);
        program.addInstruction(Instruction::PUSH1, offsetLength, Protection::Protected);
        break;
    }

    default:
        break;
    }
}


}
}