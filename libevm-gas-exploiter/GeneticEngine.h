#pragma once

#include <map>
#include <ostream>

#include "ExecutionEnv.h"
#include "InstructionMetadata.h"
#include "ProgramGenerator.h"
#include "Benchmarker.h"
#include <boost/optional.hpp>

namespace dev
{
namespace eth
{
namespace
{
const double defaultTournamentSelectionRatio = 0.2;
const double defaultTournamentSelectionProb = 0.5;
}  // namespace


class GeneticEngine
{
public:
    struct TournamentSelectionConfig
    {
        TournamentSelectionConfig()
          : sampleRatio(defaultTournamentSelectionRatio), prob(defaultTournamentSelectionProb)
        {}
        TournamentSelectionConfig(double _sampleRatio, double _prob)
          : sampleRatio(_sampleRatio), prob(_prob)
        {}

        double sampleRatio;
        double prob;
    };

    enum class Metric
    {
        Mean,
        Median
    };

    struct Config
    {
        uint32_t populationSize;
        uint32_t initialProgramSize;
        uint32_t minimumProgramSize;
        uint32_t generationsCount;
        uint32_t mutationsCount;
        double eliteRatio;
        bool debug;
        bool cacheResults;
        TournamentSelectionConfig tournamentSelectionConfig;
        ExecutionEnv execEnv;
        unsigned seed;
        Metric targetMetric;
        BenchmarkConfig benchmarkConfig;
    };

    struct EvaluatedProgram
    {
        explicit EvaluatedProgram(Program _program) : program(_program), evaluation(boost::none) {}
        EvaluatedProgram(Program _program, ExecutionAggregatedStats _evaluation)
          : program(_program), evaluation(_evaluation)
        {}
        Program program;
        boost::optional<ExecutionAggregatedStats> evaluation;
        Json::Value toJson(bool verbose = false) const;
    };

    class Stats
    {
    public:
        Stats(uint64_t generationNumber, double minThroughput, EvaluatedProgram bestProgram,
            BenchmarkStats benchmarkStats)
          : m_generationNumber(generationNumber),
            m_minThroughput(minThroughput),
            m_bestProgram(bestProgram),
            m_benchmarkStats(benchmarkStats)
        {}

        Json::Value toJson() const;
        Json::Value toJson(const std::vector<std::shared_ptr<EvaluatedProgram>>& population) const;
        uint64_t generationNumber() const { return m_generationNumber; }
        uint64_t minThroughput() const { return m_minThroughput; }
        uint64_t minProgramSize() const { return m_bestProgram.program.size(); }

    private:
        uint64_t m_generationNumber;
        double m_minThroughput;
        EvaluatedProgram m_bestProgram;
        BenchmarkStats m_benchmarkStats;
    };


    GeneticEngine(Config config, std::shared_ptr<ProgramGenerator> programGenerator,
        std::ostream& outputStream);

    void run();
    Stats computeFitness();
    void advanceGeneration();
    std::shared_ptr<EvaluatedProgram> tournamentSelection()
    {
        return tournamentSelection(m_population, m_config.tournamentSelectionConfig);
    };
    std::shared_ptr<EvaluatedProgram> tournamentSelection(
        const std::vector<std::shared_ptr<EvaluatedProgram>>& population,
        TournamentSelectionConfig config);

    /// The procedure for cross-over is as follow:
    /// 1. Compute a reversed index where the key is the stack size
    /// and the value is a list of points in the program where it has this
    /// particular stack size
    /// 2. Find the stack sizes that the two programs have in common
    /// 3. Sample one of these stack sizes based on how frequent they are
    /// 4. Select a random value in each of the reverse indexes
    /// 5. Take the first program up to the selected index
    /// and the second program up to the other selected index
    std::pair<Program, Program> crossOver(const Program& prog, const Program& other);

    /// Mutation replaces an instruction by another one in a safe way
    /// mutate repeates mutateOnce `n` times
    void mutate(Program& program, size_t n);
    void mutateOnce(Program& program);

    const std::vector<Stats>& stats() const { return m_stats; }
    const std::vector<std::shared_ptr<EvaluatedProgram>>& population() const
    {
        return m_population;
    }

    void outputStats(const Stats& stats) const;

    const Config& config() const { return m_config; }
    std::shared_ptr<ProgramGenerator> programGenerator() { return m_programGenerator; }

    std::function<bool(std::shared_ptr<EvaluatedProgram>, std::shared_ptr<EvaluatedProgram>)>
    comparePrograms();

private:
    /// Config for the genetic algorithm
    Config m_config;

    Logger m_logger{createLogger(VerbosityInfo, "genetic-engine")};

    /// The population of programs
    std::vector<std::shared_ptr<EvaluatedProgram>> m_population;

    /// Stats about each generation
    std::vector<Stats> m_stats;

    /// A generator to generate the initial set of program
    std::shared_ptr<ProgramGenerator> m_programGenerator;

    /// Output stream
    std::ostream& m_outputStream;

    std::unique_ptr<Json::StreamWriter> m_jsonWriter;

    std::default_random_engine m_generator;

    /// Helper for cross-over
    void appendProgram(Program& child, const Program& parent,
                                  size_t progSplitPoint, bool useTail);

    /// Helper to get the throughput of the program
    double getThroughput(const ExecutionAggregatedStats& stats);

    void evalOrReplace(std::shared_ptr<EvaluatedProgram> eProgram);
};

}  // namespace eth
}  // namespace dev
