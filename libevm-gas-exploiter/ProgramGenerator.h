#pragma once

#include <vector>
#include <map>

#include <boost/random.hpp>

#include <libdevcore/Common.h>
#include <libethcore/Common.h>
#include <libethcore/EVMSchedule.h>

#include "InstructionMetadata.h"
#include "Program.h"
#include "ProgramGeneratorHooks.h"

namespace dev
{

typedef boost::random::independent_bits_engine<boost::random::mt19937, 256, u256> u256_random_generator;

namespace eth
{


class ProgramGenerator
{
public:
    explicit ProgramGenerator(unsigned seed = 0) :
        ProgramGenerator(std::map<Instruction, InstructionMetadata>(), seed) {}

    explicit ProgramGenerator(
        std::map<Instruction, InstructionMetadata> metadata,
        unsigned seed = 0
    );

    Program generateInitialProgram(uint64_t programSize = 10000);

    void addHook(const std::shared_ptr<ProgramGeneratorHook> hook) { m_hooks.push_back(hook); }

    std::shared_ptr<ProgramInstruction> makeInstruction(Instruction instruction);
    ProgramData makePushData(uint8_t operandSize);

    std::map<int, std::vector<Instruction>> instructionsPerArgsCount() { return m_instructionsPerArgsCount; }

private:
    void addInstruction(Program& program, Instruction instruction);

    /// m_instructionsPerArgsCount contains a mapping with
    /// the minimum number of elements required on the
    /// stack to perform a computation and the available
    /// instructions
    std::map<int, std::vector<Instruction>> m_instructionsPerArgsCount;

    /// m_instructionsWeights contains a mapping with
    /// the minimum number of elements required on the
    /// stack to perform a computation and the weight
    /// of the available instructions
    std::map<int, std::discrete_distribution<uint8_t>> m_instructionsWeights;


    /// m_hooks contains hooks to execute before adding a new instruction
    std::vector<std::shared_ptr<ProgramGeneratorHook>> m_hooks;

    std::default_random_engine m_generator;
    u256_random_generator m_u256Generator;
};

}
}
