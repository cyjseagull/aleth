#pragma once

#include <vector>
#include <map>
#include <memory>
#include <libdevcore/Common.h>
#include <libdevcore/CommonData.h>

#include <libevm/Instruction.h>


namespace dev
{
namespace eth
{

struct ProgramData
{
    ProgramData(u256 _value, uint8_t _size) : value(_value), size(_size) {}
    ProgramData(std::string data);
    ProgramData(const char* data) : ProgramData(std::string(data)) {}
    u256 value;
    uint8_t size;
    std::string toHex() const;
};

class ProgramInstruction
{
public:
    enum class Protection
    {
        None,
        Protected
    };

    ProgramInstruction(Instruction instruction, Protection protection = Protection::None)
      : m_instruction(instruction), m_protection(protection)
    {}
    virtual ~ProgramInstruction() {}

    virtual bool hasData() const { return false; }
    Instruction instruction() const { return m_instruction; }
    virtual std::string toHex() const;
    virtual std::string toOpcode() const;
    bool isProtected() const { return m_protection == Protection::Protected; }
    void enableProtection() { m_protection = Protection::Protected; }
    void disableProtection() { m_protection = Protection::None; }

    static std::shared_ptr<ProgramInstruction> create(
        Instruction instruction, Protection protection = Protection::None)
    {
        return std::make_shared<ProgramInstruction>(instruction, protection);
    }
    static std::shared_ptr<ProgramInstruction> create(
        Instruction instruction, ProgramData data, Protection protectoin = Protection::None);

protected:
    Instruction m_instruction;
    Protection m_protection;
};

class ProgramInstructionWithData : public ProgramInstruction
{
public:
    ProgramInstructionWithData(
        Instruction instruction, ProgramData data, Protection protection = Protection::None)
      : ProgramInstruction(instruction, protection), m_data(data)
    {}
    bool hasData() const override { return true; }
    ProgramData data() const { return m_data; }
    std::string toHex() const override;
    std::string toOpcode() const override;
private:
    ProgramData m_data;
};


class Program
{
public:
    using Protection = ProgramInstruction::Protection;

    Program();
    explicit Program(std::vector<std::shared_ptr<ProgramInstruction>> _instructions);

    void addInstruction(std::shared_ptr<ProgramInstruction> instruction);
    void addInstruction(Instruction instruction, Protection protection = Protection::None);
    void addInstruction(
        Instruction instruction, ProgramData data, Protection protection = Protection::None);

    const std::vector<std::shared_ptr<ProgramInstruction>>& instructions() const
    {
        return m_instructions;
    };
    uint64_t stackSize() const { return m_stackSize.back(); }

    std::string toHex() const;
    bytes toBytes() const;
    std::string toOpcodes() const;

    Program withStop() const;

    size_t size() const { return m_instructions.size(); }

private:
    /// m_instructions is the vector of instructions in the program
    std::vector<std::shared_ptr<ProgramInstruction>> m_instructions;

    /// m_stackSize is the size of the program stack at each point of the program
    std::vector<uint64_t> m_stackSize = {0};
};

}
}
