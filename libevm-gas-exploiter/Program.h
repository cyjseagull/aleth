#pragma once

#include <vector>
#include <map>
#include <memory>
#include <libdevcore/Common.h>
#include <libdevcore/CommonData.h>

#include <libevm/Instruction.h>


namespace dev
{
namespace eth
{

struct ProgramData
{
    ProgramData(u256 _value, uint8_t _size) : value(_value), size(_size) {}
    u256 value;
    uint8_t size;
    std::string toHex() const;
};

class ProgramInstruction
{
public:
    enum class Protection
    {
        None,
        Protected
    };

    ProgramInstruction(Instruction instruction, Protection protection = Protection::None)
      : m_instruction(instruction), m_protection(protection), m_requiredBy(std::shared_ptr<ProgramInstruction>(nullptr))
    {}

    ProgramInstruction(Instruction instruction,
                       std::shared_ptr<ProgramInstruction> requiredBy)
      : m_instruction(instruction), m_protection(Protection::Protected), m_requiredBy(requiredBy)
    {}

    virtual ~ProgramInstruction() {}

    virtual bool hasData() const { return false; }
    Instruction instruction() const { return m_instruction; }
    virtual std::string toHex() const;
    virtual std::string toOpcode() const;
    Protection protection() const { return m_protection; }
    bool isProtected() const { return m_protection == Protection::Protected; }
    void enableProtection() { m_protection = Protection::Protected; }
    void disableProtection() { m_protection = Protection::None; }
    const std::shared_ptr<ProgramInstruction> requiredBy() const { return m_requiredBy.lock(); }

    static std::shared_ptr<ProgramInstruction> create(
        Instruction instruction, Protection protection = Protection::None)
    {
        return std::make_shared<ProgramInstruction>(instruction, protection);
    }
    static std::shared_ptr<ProgramInstruction> create(
        Instruction instruction, ProgramData data, Protection protection = Protection::None);

protected:
    Instruction m_instruction;
    Protection m_protection;
    std::weak_ptr<ProgramInstruction> m_requiredBy;
};

class ProgramInstructionWithData : public ProgramInstruction
{
public:
    ProgramInstructionWithData(
        Instruction instruction, ProgramData data, Protection protection = Protection::None)
      : ProgramInstruction(instruction, protection), m_data(data)
    {}
    ProgramInstructionWithData(
        Instruction instruction, ProgramData data, std::shared_ptr<ProgramInstruction> requiredBy)
      : ProgramInstruction(instruction, requiredBy), m_data(data)
    {}

    bool hasData() const override { return true; }
    ProgramData data() const { return m_data; }
    std::string toHex() const override;
    std::string toOpcode() const override;
private:
    ProgramData m_data;
};


class Program
{
public:
    using Protection = ProgramInstruction::Protection;

    Program();
    explicit Program(std::vector<std::shared_ptr<ProgramInstruction>> _instructions);

    void addInstruction(std::shared_ptr<ProgramInstruction> instruction);
    void addInstruction(Instruction instruction, Protection protection = Protection::None);
    void addInstruction(
        Instruction instruction, u256 data, Protection protection = Protection::None);
    void addInstruction(
        Instruction instruction, ProgramData data, Protection protection = Protection::None);

    void replaceInstruction(size_t index, std::vector<std::shared_ptr<ProgramInstruction>> replacement);

    const std::vector<std::shared_ptr<ProgramInstruction>>& instructions() const
    {
        return m_instructions;
    };
    uint64_t stackSize() const { return m_stackSize.back(); }

    /// Adjusts the program size so that it is between `minimumSize` and `maximumSize`
    void adjustSize(size_t minimumSize, size_t maximumSize);

    /// Extends the size at the program so that it is *at least* `minimumSize` long
    /// To do so, the set of instructions will be repeated the required number of time
    /// The size of the program will always be a multiple of the original number of instructions
    void extendSize(size_t minimumSize);

    /// Truncates the program so that it is shorter than `maximumSize`
    void limitSize(size_t maximumSize);

    std::string toHex() const;
    bytes toBytes() const;
    std::string toOpcodes() const;

    Program withStop() const;

    const std::shared_ptr<ProgramInstruction> operator[](size_t i) const { return m_instructions[i]; };

    size_t size() const { return m_instructions.size(); }
    size_t uniqueSize() const { return size() / m_repeatedTime; }

    std::map<uint64_t, std::vector<size_t>> stackSizeReverseIndex() const;


private:
    /// m_instructions is the vector of instructions in the program
    std::vector<std::shared_ptr<ProgramInstruction>> m_instructions;

    /// number of times the program is repeated
    size_t m_repeatedTime = 1;

    /// m_stackSize is the size of the program stack at each point of the program
    std::vector<uint64_t> m_stackSize = {0};


    /// recomputeStackSize recomputes the values for m_stackSize
    void recomputeStackSize();
};

}
}
