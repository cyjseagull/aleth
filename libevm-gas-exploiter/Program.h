#pragma once

#include <vector>
#include <map>
#include <memory>
#include <libdevcore/Common.h>
#include <libdevcore/CommonData.h>

#include <libevm/Instruction.h>


namespace dev
{
namespace eth
{

struct ProgramData
{
    ProgramData(u256 _value, uint8_t _size) : value(_value), size(_size) {}
    ProgramData(std::string data);
    ProgramData(const char* data) : ProgramData(std::string(data)) {}
    u256 value;
    uint8_t size;
    std::string toHex() const;
};

class ProgramInstruction
{
public:
    ProgramInstruction(Instruction instruction) : m_instruction(instruction) {}
    virtual ~ProgramInstruction() {}

    virtual bool hasData() const { return false; }
    Instruction instruction() const { return m_instruction; }
    virtual std::string toHex() const;
    virtual std::string toOpcode() const;

    static std::shared_ptr<ProgramInstruction> create(Instruction instruction) { return std::make_shared<ProgramInstruction>(instruction); }
    static std::shared_ptr<ProgramInstruction> create(Instruction instruction, ProgramData data);

protected:
    Instruction m_instruction;
};

class ProgramInstructionWithData : public ProgramInstruction
{
public:
    ProgramInstructionWithData(Instruction instruction, ProgramData data)
        : ProgramInstruction(instruction), m_data(data) {}
    bool hasData() const override { return true; }
    ProgramData data() const { return m_data; }
    std::string toHex() const override;
    std::string toOpcode() const override;
private:
    ProgramData m_data;
};


class Program
{
public:
    Program();
    explicit Program(std::vector<std::shared_ptr<ProgramInstruction>> _instructions);

    void addInstruction(std::shared_ptr<ProgramInstruction> instruction);

    void addInstruction(Instruction instruction) { addInstruction(ProgramInstruction::create(instruction)); }
    void addInstruction(Instruction instruction, ProgramData data) { addInstruction(ProgramInstruction::create(instruction, data)); }

    std::vector<std::shared_ptr<ProgramInstruction>> instructions() const { return m_instructions; };
    uint64_t stackSize() const { return m_stackSize; };

    std::string toHex() const;
    bytes toBytes() const;
    std::string toOpcodes() const;

    Program withStop() const;

private:
    /// m_instructions is the vector of instructions in the program
    std::vector<std::shared_ptr<ProgramInstruction>> m_instructions;

    /// m_stackSize is the current size of the program stack
    /// i.e. the size the stack would be if we executed all the instructions
    /// of the program
    uint64_t m_stackSize = 0;
};

}
}
