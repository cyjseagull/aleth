#include "InstructionGenerator.h"

namespace
{
    const size_t programDataSize = 1;
    const size_t minMemoryToUse = 1;
    const size_t maxMemoryToUse = (1 << (8 * programDataSize)) - 1;
    std::uniform_int_distribution<int> memoryLengthDistribution(minMemoryToUse , maxMemoryToUse);
}

namespace dev
{
namespace eth
{
using Protection = ProgramInstruction::Protection;


ProgramData randomData(std::default_random_engine randEngine)
{
    return ProgramData(memoryLengthDistribution(randEngine), programDataSize);
}

std::vector<std::shared_ptr<ProgramInstruction>> generateMemorySafeSequence(
    const std::shared_ptr<ProgramInstruction> inst, std::default_random_engine randEngine)
{
    std::vector<std::shared_ptr<ProgramInstruction>> sequence;
    switch (inst->instruction())
    {
    /// signature: CALLDATACOPY(destOffset, offset, length)
    ///            CODECOPY(destOffset, offset, length)
    ///            RETURNDATACOPY(destOffset, offset, length)
    /// stack before: x, y, z
    /// stack after:  destOffset, offset, length
    case Instruction::CALLDATACOPY:
    case Instruction::CODECOPY:
    case Instruction::RETURNDATACOPY:
    {
        inst->enableProtection();
        auto memoryLength = randomData(randEngine);
        auto offset = randomData(randEngine);
        auto destOffset = randomData(randEngine);
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, memoryLength, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, offset, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, destOffset, Protection::Protected));
        break;
    }

    /// signature: MSTORE(offset, value)
    ///            MSTORE8(offset, value)
    /// stack before: x, y
    /// stack after:  offset, y
    case Instruction::MSTORE8:
    case Instruction::MSTORE:
    {
        inst->enableProtection();
        auto offset = randomData(randEngine);
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, offset, Protection::Protected));
        break;
    }

    /// signature: MLOAD(offset)
    /// stack before: x
    /// stack after:  offset
    case Instruction::MLOAD:
    {
        inst->enableProtection();
        auto offset = randomData(randEngine);
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, offset, Protection::Protected));
        break;
    }

    /// signature: SHA3(offset, length)
    /// stack before: x, y
    /// stack after:  offset, length
    case Instruction::SHA3:
    {
        inst->enableProtection();
        auto offset = randomData(randEngine);
        auto length = randomData(randEngine);
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, length, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, offset, Protection::Protected));
        break;
    }

    /// signature: EXTCODECOPY(addr, destOffset, offset, length)
    /// stack before: a, b, c, d
    /// stack after: a, destOffset, offset, length
    case Instruction::EXTCODECOPY:
    {
        inst->enableProtection();
        auto memoryLength = randomData(randEngine);
        auto offset = randomData(randEngine);
        auto destOffset = randomData(randEngine);
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::SWAP3, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, memoryLength, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::SWAP1, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, offset, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::SWAP1, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, destOffset, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::SWAP1, Protection::Protected));
        break;
    }

    /// signature: LOG0(offset, length)
    ///            LOG1(offset, length, topic0)
    ///            LOG4(offset, length, topic0, topic1, topic2, topic3)
    /// stack before: x, y, topics...
    /// stack after:  offset, length, topics...
    case Instruction::LOG0:
    case Instruction::LOG1:
    case Instruction::LOG2:
    case Instruction::LOG3:
    case Instruction::LOG4:
    {
        inst->enableProtection();
        auto memoryLength = randomData(randEngine);
        auto offsetLength = randomData(randEngine);
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstruction>(Instruction::POP, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, memoryLength, Protection::Protected));
        sequence.push_back(std::make_shared<ProgramInstructionWithData>(Instruction::PUSH1, offsetLength, Protection::Protected));
        break;
    }

    default:
        break;
    }

    sequence.push_back(inst);

    return sequence;
}


}
}