#include "Program.h"
#include "InstructionHelpers.h"

#include <stdexcept>
#include <boost/algorithm/string.hpp>

namespace dev
{
namespace eth
{

ProgramData::ProgramData(std::string data)
{
    if (data.substr(0, 2) == "0x")
    {
        data = data.substr(2);
    }
    if (data.size() % 2 != 0)
    {
        throw std::runtime_error("string size should be a multiple of 2");
    }
    size = data.size() / 2;
    std::stringstream ss(data);
    ss >> std::hex >> value;
}

std::shared_ptr<ProgramInstruction> ProgramInstruction::create(
    Instruction instruction, ProgramData data, Protection protection)
{
    if (isPush(instruction) && (
        data.size != pushOperandSize(instruction) ||
        data.value > pushMaxValue(instruction)))
    {
        throw std::runtime_error("invalid value for PUSH");
    }
    return std::make_shared<ProgramInstructionWithData>(instruction, data, protection);
}

std::string ProgramData::toHex() const
{
    std::stringstream ss;
    size_t stringSize = size * 2;
    ss << std::hex << std::setw(stringSize) << std::setfill('0') << value;
    auto res = ss.str();
    if (res.size() > stringSize)
    {
        res = res.substr(res.size() - stringSize, res.size());
    }
    return boost::algorithm::to_lower_copy(res);
}

std::string ProgramInstruction::toHex() const
{
    std::stringstream ss;
    ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(m_instruction);
    return boost::algorithm::to_lower_copy(ss.str());
}

std::string ProgramInstructionWithData::toHex() const
{
    std::stringstream ss;
    ss << ProgramInstruction::toHex();
    ss << m_data.toHex();
    return ss.str();
}

std::string ProgramInstruction::toOpcode() const
{
    return instructionInfo(m_instruction).name;
}

std::string ProgramInstructionWithData::toOpcode() const
{
    std::stringstream ss;
    ss << ProgramInstruction::toOpcode() << ' ';
    ss << m_data.toHex();
    return ss.str();
}


Program::Program() {}
Program::Program(std::vector<std::shared_ptr<ProgramInstruction>> _instructions)
    : m_instructions(_instructions) {}


void Program::addInstruction(std::shared_ptr<ProgramInstruction> pInstruction)
{
    auto info = instructionInfo(pInstruction->instruction());
    auto currentStackSize = stackSize();
    if (static_cast<uint64_t>(info.args) > currentStackSize)
    {
        throw std::runtime_error("not enough elements on the stack");
    }
    auto stackDifference = info.ret - info.args;
    currentStackSize += stackDifference;
    m_stackSize.push_back(currentStackSize);
    m_instructions.push_back(pInstruction);
}

void Program::addInstruction(Instruction instruction, Protection protection)
{
    addInstruction(ProgramInstruction::create(instruction, protection));
}

void Program::addInstruction(Instruction instruction, ProgramData data, Protection protection)
{
    addInstruction(ProgramInstruction::create(instruction, data, protection));
}

void Program::addInstruction(Instruction instruction, u256 data, Protection protection)
{
    if (isPush(instruction))
    {
        auto dataSize = pushOperandSize(instruction);
        addInstruction(instruction, ProgramData(data, dataSize), protection);
    }
    else
    {
        throw std::invalid_argument("data can only be passed with push");
    }
}


std::string Program::toHex() const
{
    std::stringstream sstream;
    for (auto inst: m_instructions)
    {
        sstream << inst->toHex();
    }
    return sstream.str();
}

std::string Program::toOpcodes() const
{
    std::stringstream sstream;
    for (auto inst: m_instructions)
    {
        sstream << inst->toOpcode() << '\n';
    }
    return sstream.str();
}


bytes Program::toBytes() const
{
    return fromHex(toHex(), WhenError::Throw);
}


Program Program::withStop() const
{
    Program program(m_instructions);
    program.addInstruction(Instruction::STOP);
    return program;
}

std::map<uint64_t, std::vector<size_t>> Program::stackSizeReverseIndex() const
{
    std::map<uint64_t, std::vector<size_t>> reverseIndex;
    for (size_t i = 1; i < m_instructions.size(); i++)
    {
        auto& instr = m_instructions[i];
        if (instr->isProtected())
        {
            continue;
        }
        auto stackSize = m_stackSize[i];
        auto& positions = reverseIndex[stackSize];
        positions.push_back(i);
    }
    return reverseIndex;
}

}
}
