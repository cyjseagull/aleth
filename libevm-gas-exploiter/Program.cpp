#include "Program.h"
#include "InstructionHelpers.h"

#include <stdexcept>
#include <boost/algorithm/string.hpp>

namespace dev
{
namespace eth
{

std::shared_ptr<ProgramInstruction> ProgramInstruction::create(
    Instruction instruction, ProgramData data, Protection protection)
{
    if (isPush(instruction) && (
        data.size != pushOperandSize(instruction) ||
        data.value > pushMaxValue(instruction)))
    {
        throw std::runtime_error("invalid value for PUSH");
    }
    return std::make_shared<ProgramInstructionWithData>(instruction, data, protection);
}

std::string ProgramData::toHex() const
{
    std::stringstream ss;
    size_t stringSize = size * 2;
    ss << std::hex << std::setw(stringSize) << std::setfill('0') << value;
    auto res = ss.str();
    if (res.size() > stringSize)
    {
        res = res.substr(res.size() - stringSize, res.size());
    }
    return boost::algorithm::to_lower_copy(res);
}

std::string ProgramInstruction::toHex() const
{
    std::stringstream ss;
    ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(m_instruction);
    return boost::algorithm::to_lower_copy(ss.str());
}

std::string ProgramInstructionWithData::toHex() const
{
    std::stringstream ss;
    ss << ProgramInstruction::toHex();
    ss << m_data.toHex();
    return ss.str();
}

std::string ProgramInstruction::toOpcode() const
{
    return instructionInfo(m_instruction).name;
}

std::string ProgramInstructionWithData::toOpcode() const
{
    std::stringstream ss;
    ss << ProgramInstruction::toOpcode() << ' ';
    ss << m_data.toHex();
    return ss.str();
}


Program::Program() {}
Program::Program(std::vector<std::shared_ptr<ProgramInstruction>> _instructions)
    : m_instructions(_instructions) {}


void Program::addInstruction(std::shared_ptr<ProgramInstruction> pInstruction)
{
    auto info = instructionInfo(pInstruction->instruction());
    auto currentStackSize = stackSize();
    if (static_cast<uint64_t>(info.args) > currentStackSize)
    {
        throw std::runtime_error("not enough elements on the stack");
    }
    auto stackDifference = info.ret - info.args;
    currentStackSize += stackDifference;
    m_stackSize.push_back(currentStackSize);
    m_instructions.push_back(pInstruction);
}

void Program::addInstruction(Instruction instruction, Protection protection)
{
    addInstruction(ProgramInstruction::create(instruction, protection));
}

void Program::addInstruction(Instruction instruction, ProgramData data, Protection protection)
{
    if (isPush(instruction))
    {
        addInstruction(ProgramInstruction::create(instruction, data, protection));
    }
    else
    {
        throw std::invalid_argument("data can only be passed with push");
    }
}

void Program::addInstruction(Instruction instruction, u256 data, Protection protection)
{
    auto dataSize = isPush(instruction) ? pushOperandSize(instruction) : 0;
    addInstruction(instruction, ProgramData(data, dataSize), protection);
}


std::string Program::toHex() const
{
    std::stringstream sstream;
    for (auto inst: m_instructions)
    {
        sstream << inst->toHex();
    }
    return sstream.str();
}

std::string Program::toOpcodes() const
{
    std::stringstream sstream;
    for (auto inst: m_instructions)
    {
        sstream << inst->toOpcode() << '\n';
    }
    return sstream.str();
}


bytes Program::toBytes() const
{
    return fromHex(toHex(), WhenError::Throw);
}


void Program::adjustSize(size_t minimumSize, size_t maximumSize)
{
    auto currentSize = size();
    if (currentSize > maximumSize)
    {
        limitSize(maximumSize);
    }
    else if (currentSize < minimumSize)
    {
        extendSize(minimumSize);
    }
}

void Program::limitSize(size_t maximumSize)
{
    if (size() > maximumSize)
    {
        m_instructions.resize(maximumSize);
        m_stackSize.resize(maximumSize + 1);
    }
}

void Program::extendSize(size_t minimumSize)
{
    auto instToRepeat = uniqueSize();
    while (size() < minimumSize)
    {
        for (size_t i = 0; i < instToRepeat; i++)
        {
            addInstruction(m_instructions[i]);
        }
        m_repeatedTime++;
    }
}


void Program::replaceInstruction(size_t index, std::vector<std::shared_ptr<ProgramInstruction>> replacement)
{
    if (replacement.empty())
    {
        throw std::invalid_argument("replacement cannot be empty");
    }

    auto instr = m_instructions[index];

    // check that the stack stays consistent
    auto replacedInfo = instructionInfo(instr->instruction());
    auto replacementInfo = instructionInfo(replacement[replacement.size() - 1]->instruction());
    auto stackSizeDiff = (replacementInfo.ret - replacementInfo.args) - (replacedInfo.ret - replacedInfo.args);
    if (replacementInfo.args > replacedInfo.args || stackSizeDiff < 0)
    {
        throw std::invalid_argument("replacement must use <= args and return >= values");
    }

    // list up all the indexes to replace (including PUSH/POP dependencies)
    std::vector<size_t> indexesToReplace = { index };
    for (size_t i = index; i > 0 && m_instructions[i - 1]->requiredBy() == instr; i--)
    {
        indexesToReplace.push_back(i - 1);
    }
    std::reverse(indexesToReplace.begin(), indexesToReplace.end());

    // replace values
    size_t i;
    for (i = 0; i < indexesToReplace.size() && i < replacement.size(); i++)
    {
        m_instructions[indexesToReplace[i]] = replacement[i];
    }

    // if the replaced and replacement were the same size
    // both vectors should be fully consumed
    if (i == indexesToReplace.size() && i == replacement.size())
    {
        // adjust the stack sizes if necessary
        if (stackSizeDiff != 0)
        {
            recomputeStackSize();
        }
        return;
    }
    // otherwise, we need to consume the rest
    // and to adjust the stack size
    else if (i < indexesToReplace.size())
    {
        for (size_t j = i; j < indexesToReplace.size(); j++)
        {
            m_instructions.erase(m_instructions.begin() + indexesToReplace[i]);
        }
    }
    else if (i < replacement.size())
    {
        for (; i < replacement.size(); i++)
        {
            m_instructions.insert(m_instructions.begin() + indexesToReplace[0] + i, replacement[i]);
        }
    }
    recomputeStackSize();
}

void Program::recomputeStackSize()
{
    size_t stackSize = 0;
    m_stackSize = {stackSize};
    for (auto instr : m_instructions)
    {
        auto info = instructionInfo(instr->instruction());
        auto stackDifference = info.ret - info.args;
        stackSize += stackDifference;
        m_stackSize.push_back(stackSize);
    }
}

Program Program::withStop() const
{
    Program program(m_instructions);
    program.addInstruction(Instruction::STOP);
    return program;
}

std::map<uint64_t, std::vector<size_t>> Program::stackSizeReverseIndex() const
{
    std::map<uint64_t, std::vector<size_t>> reverseIndex;
    for (size_t i = 1; i < m_instructions.size(); i++)
    {
        auto& instr = m_instructions[i];
        if (instr->isProtected())
        {
            continue;
        }
        auto stackSize = m_stackSize[i];
        auto& positions = reverseIndex[stackSize];
        positions.push_back(i);
    }
    return reverseIndex;
}

}
}
