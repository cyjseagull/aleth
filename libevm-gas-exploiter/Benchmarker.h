#pragma once

#include <json/json.h>

#include "ExecutionEnv.h"
#include "ProgramGenerator.h"

namespace dev
{
namespace eth
{
struct BenchmarkStats
{
    double blockExecutionTimeMean;
    double blockExecutionTimeMedian;
    double blockExecutionTimeStdev;
    double blockGas;
    double blockThroughputMean;
    double blockThroughputMedian;
    std::vector<double> blockExecutionTimes;
    std::vector<ExecutionAggregatedStats> programStats;

    Json::Value toJson(bool verbose = false) const;
};

struct BenchmarkConfig
{
    BenchmarkConfig(uint64_t _execCount, bool _debug = false,
                    uint16_t _initialWarmupCount = 5, bool _warmup = true,
                    bool _dropCaches = false, bool _alwaysDropCache = false)
        : execCount(_execCount), debug(_debug),
          initialWarmupCount(_initialWarmupCount), warmup(_warmup),
          dropCaches(_dropCaches), alwaysDropCache(_alwaysDropCache) {}

    uint64_t execCount;
    bool debug = false;
    uint16_t initialWarmupCount;
    bool warmup = true;
    bool dropCaches = false;
    bool alwaysDropCache = false;
};

ExecutionStats executeCode(bytes code, ExecutionEnv execEnv, bool debug = false);
ExecutionAggregatedStats benchmarkCode(ExecutionEnv execEnv, bytes code, const BenchmarkConfig& config);
BenchmarkStats benchmarkCodes(
    ExecutionEnv execEnv, const std::vector<bytes>& codes, const BenchmarkConfig& config);

void runInitialWarmup(
    std::shared_ptr<ProgramGenerator> programGenerator,
    ExecutionEnv execEnv,
    const BenchmarkConfig& config,
    uint32_t programSize,
    uint32_t populationSize,
    uint16_t executionTimes = 5
);


}
}
