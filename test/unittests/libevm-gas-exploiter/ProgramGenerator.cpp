#include <libevm-gas-exploiter/ProgramGenerator.h>

#include <gtest/gtest.h>

using namespace dev;
using namespace eth;


TEST(ProgramGenerator, instructionsPerArgsCount)
{
    ProgramGenerator programGenerator;
    auto instPerArgs = programGenerator.instructionsPerArgsCount();
    for (int i = 0; i < 12; i++)
    {
        auto instrs = instPerArgs[i];
        ASSERT_EQ(std::find(instrs.begin(), instrs.end(), Instruction::DUP13), instrs.end());
    }

    if (getenv("ALETH_DEBUG") == nullptr)
    {
        return;
    }
    for (auto& kv : instPerArgs)
    {
        std::cout << kv.first << ": ";
        for (auto inst : kv.second)
        {
            std::cout << instructionInfo(inst).name << " ";
        }
        std::cout << std::endl;
    }
}

TEST(ProgramGenerator, makePushData)
{
    ProgramGenerator programGenerator;
    for (size_t i = 0; i < 100; i++)
    {
        ASSERT_LE(programGenerator.makePushData(1).value, 0xff);
        ASSERT_LE(programGenerator.makePushData(2).value, 0xffff);
    }
}

TEST(ProgramGenerator, makeInstruction)
{
    ProgramGenerator programGenerator;
    auto instr = programGenerator.makeInstruction(Instruction::ADD);
    EXPECT_FALSE(instr->hasData());

    instr = programGenerator.makeInstruction(Instruction::PUSH1);
    EXPECT_EQ(instr->instruction(), Instruction::PUSH1);
    ASSERT_TRUE(instr->hasData());
    auto instrWData = std::dynamic_pointer_cast<ProgramInstructionWithData>(instr);
    auto data = instrWData->data();
    EXPECT_EQ(data.size, uint8_t(1));
    EXPECT_EQ(instrWData->toHex().size(), 4);

    instr = programGenerator.makeInstruction(Instruction::PUSH2);
    EXPECT_EQ(instr->instruction(), Instruction::PUSH2);
    ASSERT_TRUE(instr->hasData());
    instrWData = std::dynamic_pointer_cast<ProgramInstructionWithData>(instr);
    data = instrWData->data();
    EXPECT_EQ(data.size, uint8_t(2));
    EXPECT_EQ(instrWData->toHex().size(), 6);
}
