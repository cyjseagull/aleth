#include <libevm-gas-exploiter/GeneticEngine.h>

#include <memory>
#include <gtest/gtest.h>

#include <libethashseal/GenesisInfo.h>
#include <libethashseal/Ethash.h>
#include <libdevcore/DBFactory.h>
#include <libethcore/SealEngine.h>

using namespace dev;
using namespace eth;


namespace
{
const uint32_t populationSize = 10;

ExecutionEnv createExecutionEnv()
{
    Ethash::init();
    NoProof::init();
    auto networkName = Network::MainNetworkTest;
    ChainParams chainParams(genesisInfo(networkName), genesisStateRoot(networkName));
    WithExisting withExisting = WithExisting::Trust;
    InstructionsBenchmark instructionsBenchmark;
    auto analysisEnv = std::make_shared<AnalysisEnv>(std::cout, std::cout, instructionsBenchmark);
    auto dbPath = db::databasePath();
    int64_t gasLimit = chainParams.maxGasLimit.convert_to<int64_t>();

    BlockChain blockchain(chainParams, dbPath, withExisting,
                          [](unsigned, unsigned) {}, analysisEnv);

    OverlayDB stateDB;

    auto block = blockchain.genesisBlock(stateDB);
    auto originalBlockHeader = block.info();
    originalBlockHeader.setGasLimit(gasLimit);

    return ExecutionEnv {
        .block = block,
        .blockHeader = block.info(),
        .value = 0,
        .gasPrice = 0,
        .gas = gasLimit,
        .sender = Address(777),
        .origin = Address(777),
        .chain = blockchain,
    };
}


GeneticEngine::Config createConfig()
{
    auto execEnv = createExecutionEnv();
    return GeneticEngine::Config {
        .populationSize = populationSize,
        .initialProgramSize = 10,
        .generationsCount = 10,
        .debug = false,
        .benchmarkExecCount = 10,
        .execEnv = execEnv,
        .seed = 0,
    };
}

GeneticEngine createEngine()
{
    auto config = createConfig();
    auto programGenerator = std::unique_ptr<ProgramGenerator>(new ProgramGenerator);
    return GeneticEngine(config, std::move(programGenerator));
}
}



TEST(GeneticEngine, constructor)
{
    auto engine = createEngine();
    EXPECT_EQ(engine.population().size(), populationSize);
    for (const auto& individual : engine.population())
    {
        ASSERT_FALSE(individual.evaluation.is_initialized());
    }
}

TEST(GeneticEngine, computeFitness)
{
    auto engine = createEngine();
    auto stats = engine.computeFitness();
    EXPECT_EQ(stats.generationNumber, 0);
    ASSERT_LE(stats.minThroughput, stats.averageThroughput);

    for (const auto& individual : engine.population())
    {
        ASSERT_TRUE(individual.evaluation.is_initialized());
    }
}
