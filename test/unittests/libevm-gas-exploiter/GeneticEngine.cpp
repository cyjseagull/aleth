#include <libevm-gas-exploiter/GeneticEngine.h>
#include <libevm-gas-exploiter/Benchmarker.h>
#include <libevm-gas-exploiter/ProgramGeneratorFactory.h>

#include <memory>
#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include <libethashseal/GenesisInfo.h>
#include <libethashseal/Ethash.h>
#include <libdevcore/DBFactory.h>
#include <libethcore/SealEngine.h>

using namespace dev;
using namespace eth;


namespace
{
const uint32_t populationSize = 10;
const uint32_t generationsCount = 10;

ExecutionEnv createExecutionEnv()
{
    Ethash::init();
    NoProof::init();
    auto networkName = Network::MainNetworkTest;
    ChainParams chainParams(genesisInfo(networkName), genesisStateRoot(networkName));
    WithExisting withExisting = WithExisting::Trust;
    InstructionsBenchmark instructionsBenchmark;
    auto analysisEnv = std::make_shared<AnalysisEnv>(std::cout, std::cout, instructionsBenchmark);
    auto dbPath = db::databasePath();
    int64_t gasLimit = chainParams.maxGasLimit.convert_to<int64_t>();

    auto blockchain = std::make_shared<BlockChain>(
        chainParams, dbPath, withExisting, [](unsigned, unsigned) {}, analysisEnv);

    // OverlayDB stateDB;
    auto stateDB = State::openDB(dbPath, blockchain->genesisHash(), withExisting);

    auto block = blockchain->genesisBlock(stateDB);
    block.sync(*blockchain);
    auto blockHeader = block.info();
    blockHeader.setGasLimit(gasLimit);

    return ExecutionEnv{
        .block = block,
        .blockHeader = blockHeader,
        .value = 0,
        .gasPrice = 0,
        .gas = gasLimit,
        .sender = Address(777),
        .origin = Address(777),
        .chain = blockchain,
    };
}


GeneticEngine::Config createConfig()
{
    auto execEnv = createExecutionEnv();
    bool debug = false;
    auto debugEnv = getenv("ALETH_DEBUG");
    if (debugEnv != nullptr && std::string(debugEnv) != "0")
    {
        debug = true;
    }
    return GeneticEngine::Config{
        .populationSize = populationSize,
        .initialProgramSize = 1000,
        .generationsCount = generationsCount,
        .eliteRatio = 0.2,
        .debug = debug,
        .benchmarkExecCount = 10,
        .tournamentSelectionConfig = GeneticEngine::TournamentSelectionConfig(),
        .execEnv = execEnv,
        .seed = 0,
    };
}

GeneticEngine createEngine()
{
    auto config = createConfig();
    std::shared_ptr<ProgramGenerator> programGenerator = programgenerator::createWithAllHooks(config.seed);
    return GeneticEngine(config, programGenerator);
}
}



TEST(GeneticEngine, constructor)
{
    auto engine = createEngine();
    EXPECT_EQ(engine.population().size(), populationSize);
    for (const auto& individual : engine.population())
    {
        ASSERT_FALSE(individual->evaluation.is_initialized());
    }
}

TEST(GeneticEngine, computeFitness)
{
    auto engine = createEngine();
    auto stats = engine.computeFitness();
    EXPECT_EQ(stats.generationNumber, 0);
    ASSERT_GT(stats.minThroughput, 0);
    ASSERT_LE(stats.minThroughput, stats.averageThroughput);

    for (const auto& individual : engine.population())
    {
        ASSERT_TRUE(individual->evaluation.is_initialized());
    }
}

TEST(GeneticEngine, crossOver)
{
    auto engine = createEngine();
    auto config = engine.config();
    auto programGenerator = engine.programGenerator();
    for (size_t i = 0; i < 100; i++)
    {
        auto prog1 = programGenerator->generateInitialProgram(config.initialProgramSize);
        auto prog2 = programGenerator->generateInitialProgram(config.initialProgramSize);
        auto child = engine.crossOver(prog1, prog2);
        EXPECT_GT(child.size(), 0);
        auto childInstrs = child.instructions();
        EXPECT_EQ(childInstrs[0], prog1.instructions()[0]);
        auto prog2Instrs = prog2.instructions();
        EXPECT_EQ(childInstrs[childInstrs.size() - 1], prog2Instrs[prog2Instrs.size() - 1]);
        auto result = executeCode(child.toBytes(), config.execEnv);
        EXPECT_EQ(result.excepted, TransactionException::None);
    }
}

TEST(GeneticEngine, tournamentSelection)
{
    auto makeEvaluation = [](double gasPerSecond) -> ExecutionAggregatedStats {
        return ExecutionAggregatedStats{
            .gas = 0,
            .totalTime = 0.0,
            .gasPerSecond = gasPerSecond,
            .timeMean = 0.0,
            .timeStdev = 0.0,
        };
    };

    std::vector<std::shared_ptr<GeneticEngine::EvaluatedProgram>> programs{
        std::make_shared<GeneticEngine::EvaluatedProgram>(Program(), makeEvaluation(0.1)),
        std::make_shared<GeneticEngine::EvaluatedProgram>(Program(), makeEvaluation(0.3)),
        std::make_shared<GeneticEngine::EvaluatedProgram>(Program(), makeEvaluation(0.2)),
        std::make_shared<GeneticEngine::EvaluatedProgram>(Program(), makeEvaluation(0.05)),
        std::make_shared<GeneticEngine::EvaluatedProgram>(Program(), makeEvaluation(0.2)),
    };
    auto engine = createEngine();
    // deterministically pick the best candidate
    auto tournamentConfig = GeneticEngine::TournamentSelectionConfig(1.0, 1.0);
    auto prog = engine.tournamentSelection(programs, tournamentConfig);
    EXPECT_EQ(prog, programs[3]);
}


TEST(GeneticEngine, advanceGeneration)
{
    auto engine = createEngine();
    engine.advanceGeneration();
    engine.advanceGeneration();
    engine.advanceGeneration();
    auto& stats = engine.stats();
    EXPECT_EQ(stats.size(), 3);
    EXPECT_LE(stats[1].minThroughput, stats[0].minThroughput);
    EXPECT_LE(stats[2].minThroughput, stats[1].minThroughput);
}

TEST(GeneticEngine, run)
{
    auto engine = createEngine();
    engine.run();
    auto& stats = engine.stats();
    EXPECT_EQ(stats.size(), generationsCount);
    EXPECT_LE(stats[generationsCount - 1].minThroughput, stats[0].minThroughput);
}
