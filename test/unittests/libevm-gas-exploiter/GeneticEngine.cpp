#include <libevm-gas-exploiter/GeneticEngine.h>
#include <libevm-gas-exploiter/ProgramGeneratorFactory.h>

#include <memory>
#include <gtest/gtest.h>

#include <libethashseal/GenesisInfo.h>
#include <libethashseal/Ethash.h>
#include <libdevcore/DBFactory.h>
#include <libethcore/SealEngine.h>

using namespace dev;
using namespace eth;


namespace
{
const uint32_t populationSize = 10;

ExecutionEnv createExecutionEnv()
{
    Ethash::init();
    NoProof::init();
    auto networkName = Network::MainNetworkTest;
    ChainParams chainParams(genesisInfo(networkName), genesisStateRoot(networkName));
    WithExisting withExisting = WithExisting::Trust;
    InstructionsBenchmark instructionsBenchmark;
    auto analysisEnv = std::make_shared<AnalysisEnv>(std::cout, std::cout, instructionsBenchmark);
    auto dbPath = db::databasePath();
    int64_t gasLimit = chainParams.maxGasLimit.convert_to<int64_t>();

    auto blockchain = std::make_shared<BlockChain>(
        chainParams, dbPath, withExisting, [](unsigned, unsigned) {}, analysisEnv);

    // OverlayDB stateDB;
    auto stateDB = State::openDB(dbPath, blockchain->genesisHash(), withExisting);

    auto block = blockchain->genesisBlock(stateDB);
    block.sync(*blockchain);
    auto blockHeader = block.info();
    blockHeader.setGasLimit(gasLimit);

    return ExecutionEnv{
        .block = block,
        .blockHeader = blockHeader,
        .value = 0,
        .gasPrice = 0,
        .gas = gasLimit,
        .sender = Address(777),
        .origin = Address(777),
        .chain = blockchain,
    };
}


GeneticEngine::Config createConfig()
{
    auto execEnv = createExecutionEnv();
    bool debug = false;
    auto debugEnv = getenv("ALETH_DEBUG");
    if (debugEnv != nullptr && std::string(debugEnv) != "0")
    {
        debug = true;
    }
    return GeneticEngine::Config{
        .populationSize = populationSize,
        .initialProgramSize = 10,
        .generationsCount = 10,
        .debug = debug,
        .benchmarkExecCount = 10,
        .execEnv = execEnv,
        .seed = 0,
    };
}

GeneticEngine createEngine()
{
    auto config = createConfig();
    auto programGenerator = programgenerator::createWithAllHooks(config.seed);
    return GeneticEngine(config, std::move(programGenerator));
}
}



TEST(GeneticEngine, constructor)
{
    auto engine = createEngine();
    EXPECT_EQ(engine.population().size(), populationSize);
    for (const auto& individual : engine.population())
    {
        ASSERT_FALSE(individual.evaluation.is_initialized());
    }
}

TEST(GeneticEngine, computeFitness)
{
    auto engine = createEngine();
    auto stats = engine.computeFitness();
    EXPECT_EQ(stats.generationNumber, 0);
    ASSERT_LE(stats.minThroughput, stats.averageThroughput);

    for (const auto& individual : engine.population())
    {
        ASSERT_TRUE(individual.evaluation.is_initialized());
    }
}
